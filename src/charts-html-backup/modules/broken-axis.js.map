{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v12.4.0 (2025-09-04)\n * @module highcharts/modules/broken-axis\n * @requires highcharts\n *\n * (c) 2009-2025 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(root[\"_Highcharts\"], root[\"_Highcharts\"][\"StackItem\"]);\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"highcharts/modules/broken-axis\", [\"highcharts/highcharts\"], function (amd1) {return factory(amd1,amd1[\"StackItem\"]);});\n\telse if(typeof exports === 'object')\n\t\texports[\"highcharts/modules/broken-axis\"] = factory(root[\"_Highcharts\"], root[\"_Highcharts\"][\"StackItem\"]);\n\telse\n\t\troot[\"Highcharts\"] = factory(root[\"Highcharts\"], root[\"Highcharts\"][\"StackItem\"]);\n})(typeof window === 'undefined' ? this : window, (__WEBPACK_EXTERNAL_MODULE__944__, __WEBPACK_EXTERNAL_MODULE__184__) => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 184:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__184__;\n\n/***/ }),\n\n/***/ 944:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__944__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__webpack_require__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ broken_axis_src)\n});\n\n// EXTERNAL MODULE: external {\"amd\":[\"highcharts/highcharts\"],\"commonjs\":[\"highcharts\"],\"commonjs2\":[\"highcharts\"],\"root\":[\"Highcharts\"]}\nvar highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_ = __webpack_require__(944);\nvar highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default = /*#__PURE__*/__webpack_require__.n(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_);\n// EXTERNAL MODULE: external {\"amd\":[\"highcharts/highcharts\",\"StackItem\"],\"commonjs\":[\"highcharts\",\"StackItem\"],\"commonjs2\":[\"highcharts\",\"StackItem\"],\"root\":[\"Highcharts\",\"StackItem\"]}\nvar highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_ = __webpack_require__(184);\nvar highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_default = /*#__PURE__*/__webpack_require__.n(highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_);\n;// ./code/es-modules/Core/Axis/BrokenAxis.js\n/* *\n *\n *  (c) 2009-2025 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n\n\n\nconst { addEvent, find, fireEvent, isArray, isNumber, pick } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Composition\n *\n * */\n/**\n * Axis with support of broken data rows.\n * @private\n */\nvar BrokenAxis;\n(function (BrokenAxis) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Adds support for broken axes.\n     * @private\n     */\n    function compose(AxisClass, SeriesClass) {\n        if (!AxisClass.keepProps.includes('brokenAxis')) {\n            AxisClass.keepProps.push('brokenAxis');\n            addEvent(AxisClass, 'init', onAxisInit);\n            addEvent(AxisClass, 'afterInit', onAxisAfterInit);\n            addEvent(AxisClass, 'afterSetTickPositions', onAxisAfterSetTickPositions);\n            addEvent(AxisClass, 'afterSetOptions', onAxisAfterSetOptions);\n            const seriesProto = SeriesClass.prototype;\n            seriesProto.drawBreaks = seriesDrawBreaks;\n            seriesProto.gappedPath = seriesGappedPath;\n            addEvent(SeriesClass, 'afterGeneratePoints', onSeriesAfterGeneratePoints);\n            addEvent(SeriesClass, 'afterRender', onSeriesAfterRender);\n        }\n        return AxisClass;\n    }\n    BrokenAxis.compose = compose;\n    /**\n     * @private\n     */\n    function onAxisAfterInit() {\n        if (typeof this.brokenAxis !== 'undefined') {\n            this.brokenAxis.setBreaks(this.options.breaks, false);\n        }\n    }\n    /**\n     * Force Axis to be not-ordinal when breaks are defined.\n     * @private\n     */\n    function onAxisAfterSetOptions() {\n        const axis = this;\n        // Too early for axis.brokenAxis?.hasBreaks.\n        if (Object.keys(axis.options.breaks?.[0] || {}).length) {\n            axis.options.ordinal = false;\n        }\n    }\n    /**\n     * @private\n     */\n    function onAxisAfterSetTickPositions() {\n        const axis = this, brokenAxis = axis.brokenAxis;\n        if (brokenAxis?.hasBreaks) {\n            const tickPositions = axis.tickPositions, info = axis.tickPositions.info, newPositions = [];\n            for (let i = 0; i < tickPositions.length; i++) {\n                if (!brokenAxis.isInAnyBreak(tickPositions[i])) {\n                    newPositions.push(tickPositions[i]);\n                }\n            }\n            axis.tickPositions = newPositions;\n            axis.tickPositions.info = info;\n        }\n    }\n    /**\n     * @private\n     */\n    function onAxisInit() {\n        const axis = this;\n        if (!axis.brokenAxis) {\n            axis.brokenAxis = new Additions(axis);\n        }\n    }\n    /**\n     * @private\n     */\n    function onSeriesAfterGeneratePoints() {\n        const { isDirty, options: { connectNulls }, points, xAxis, yAxis } = this;\n        // Set, or reset visibility of the points. Axis.setBreaks marks\n        // the series as isDirty\n        if (isDirty) {\n            let i = points.length;\n            while (i--) {\n                const point = points[i];\n                // Respect nulls inside the break (#4275)\n                const nullGap = point.y === null && connectNulls === false;\n                const isPointInBreak = (!nullGap && (xAxis?.brokenAxis?.isInAnyBreak(point.x, true) ||\n                    yAxis?.brokenAxis?.isInAnyBreak(point.y, true)));\n                // Set point.visible if in any break.\n                // If not in break, reset visible to original value.\n                point.visible = isPointInBreak ?\n                    false :\n                    point.options.visible !== false;\n            }\n        }\n    }\n    /**\n     * @private\n     */\n    function onSeriesAfterRender() {\n        this.drawBreaks(this.xAxis, ['x']);\n        this.drawBreaks(this.yAxis, pick(this.pointArrayMap, ['y']));\n    }\n    /**\n     * @private\n     */\n    function seriesDrawBreaks(axis, keys) {\n        const series = this, points = series.points;\n        let breaks, threshold, y;\n        if (axis?.brokenAxis?.hasBreaks) {\n            const brokenAxis = axis.brokenAxis;\n            keys.forEach(function (key) {\n                breaks = brokenAxis?.breakArray || [];\n                threshold = axis.isXAxis ?\n                    axis.min :\n                    pick(series.options.threshold, axis.min);\n                points.forEach(function (point) {\n                    y = point['stack' + key.toUpperCase()] ??\n                        point[key];\n                    breaks.forEach(function (brk) {\n                        if (isNumber(threshold) && isNumber(y)) {\n                            let eventName = '';\n                            if ((threshold < brk.from && y > brk.to) ||\n                                (threshold > brk.from && y < brk.from)) {\n                                eventName = 'pointBreak';\n                            }\n                            else if ((threshold < brk.from &&\n                                y > brk.from &&\n                                y < brk.to) || (threshold > brk.from &&\n                                y > brk.to &&\n                                y < brk.from)) {\n                                eventName = 'pointInBreak';\n                            }\n                            if (eventName) {\n                                fireEvent(axis, eventName, { point, brk });\n                            }\n                        }\n                    });\n                });\n            });\n        }\n    }\n    /**\n     * Extend getGraphPath by identifying gaps in the data so that we\n     * can draw a gap in the line or area. This was moved from ordinal\n     * axis module to broken axis module as of #5045.\n     *\n     * @private\n     * @function Highcharts.Series#gappedPath\n     *\n     * @return {Highcharts.SVGPathArray}\n     * Gapped path\n     */\n    function seriesGappedPath() {\n        const currentDataGrouping = this.currentDataGrouping, groupingSize = currentDataGrouping?.gapSize, points = this.points.slice(), yAxis = this.yAxis;\n        let gapSize = this.options.gapSize, i = points.length - 1, stack;\n        /**\n         * Defines when to display a gap in the graph, together with the\n         * [gapUnit](plotOptions.series.gapUnit) option.\n         *\n         * In case when `dataGrouping` is enabled, points can be grouped\n         * into a larger time span. This can make the grouped points to\n         * have a greater distance than the absolute value of `gapSize`\n         * property, which will result in disappearing graph completely.\n         * To prevent this situation the mentioned distance between\n         * grouped points is used instead of previously defined\n         * `gapSize`.\n         *\n         * In practice, this option is most often used to visualize gaps\n         * in time series. In a stock chart, intraday data is available\n         * for daytime hours, while gaps will appear in nights and\n         * weekends.\n         *\n         * @see [gapUnit](plotOptions.series.gapUnit)\n         * @see [xAxis.breaks](#xAxis.breaks)\n         *\n         * @sample {highstock} stock/plotoptions/series-gapsize/\n         * Setting the gap size to 2 introduces gaps for weekends in\n         * daily datasets.\n         *\n         * @type      {number}\n         * @default   0\n         * @product   highstock\n         * @requires  modules/broken-axis\n         * @apioption plotOptions.series.gapSize\n         */\n        /**\n         * Together with [gapSize](plotOptions.series.gapSize), this\n         * option defines where to draw gaps in the graph.\n         *\n         * When the `gapUnit` is `\"relative\"` (default), a gap size of 5\n         * means that if the distance between two points is greater than\n         * 5 times that of the two closest points, the graph will be\n         * broken.\n         *\n         * When the `gapUnit` is `\"value\"`, the gap is based on absolute\n         * axis values, which on a datetime axis is milliseconds. This\n         * also applies to the navigator series that inherits gap\n         * options from the base series.\n         *\n         * @see [gapSize](plotOptions.series.gapSize)\n         *\n         * @type       {string}\n         * @default    relative\n         * @since      5.0.13\n         * @product    highstock\n         * @validvalue [\"relative\", \"value\"]\n         * @requires   modules/broken-axis\n         * @apioption  plotOptions.series.gapUnit\n         */\n        if (gapSize && i > 0) { // #5008\n            // Gap unit is relative\n            if (this.options.gapUnit !== 'value') {\n                gapSize *= this.basePointRange;\n            }\n            // Setting a new gapSize in case dataGrouping is enabled\n            // (#7686)\n            if (groupingSize &&\n                groupingSize > gapSize &&\n                // Except when DG is forced (e.g. from other series)\n                // and has lower granularity than actual points (#11351)\n                groupingSize >= this.basePointRange) {\n                gapSize = groupingSize;\n            }\n            // Extension for ordinal breaks\n            let current, next;\n            while (i--) {\n                // Reassign next if it is not visible\n                if (!(next && next.visible !== false)) {\n                    next = points[i + 1];\n                }\n                current = points[i];\n                // Skip iteration if one of the points is not visible\n                if (next.visible === false || current.visible === false) {\n                    continue;\n                }\n                if (next.x - current.x > gapSize) {\n                    const xRange = (current.x + next.x) / 2;\n                    points.splice(// Insert after this one\n                    i + 1, 0, {\n                        isNull: true,\n                        x: xRange\n                    });\n                    // For stacked chart generate empty stack items, #6546\n                    if (yAxis.stacking && this.options.stacking) {\n                        stack = yAxis.stacking.stacks[this.stackKey][xRange] = new (highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_default())(yAxis, yAxis.options.stackLabels, false, xRange, this.stack);\n                        stack.total = 0;\n                    }\n                }\n                // Assign current to next for the upcoming iteration\n                next = current;\n            }\n        }\n        // Call base method\n        return this.getGraphPath(points);\n    }\n    /* *\n     *\n     *  Class\n     *\n     * */\n    /**\n     * Provides support for broken axes.\n     * @private\n     * @class\n     */\n    class Additions {\n        /* *\n         *\n         *  Static Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        static isInBreak(brk, val) {\n            const repeat = brk.repeat || Infinity, from = brk.from, length = brk.to - brk.from, test = (val >= from ?\n                (val - from) % repeat :\n                repeat - ((from - val) % repeat));\n            let ret;\n            if (!brk.inclusive) {\n                ret = test < length && test !== 0;\n            }\n            else {\n                ret = test <= length;\n            }\n            return ret;\n        }\n        /**\n         * @private\n         */\n        static lin2Val(val) {\n            const axis = this, threshold = axis.min || 0, brokenAxis = axis.brokenAxis, breakArray = brokenAxis?.breakArray;\n            if (!breakArray?.length || !isNumber(val)) {\n                return val;\n            }\n            let nval = val;\n            // Axis min is the anchor point. Above it, break gaps impact the\n            // result differently than below.\n            if (val > threshold) {\n                for (const brk of breakArray) {\n                    if (brk.from > nval) {\n                        // Skip all breaks after the nval.\n                        break;\n                    }\n                    else if (brk.to <= nval && brk.to > threshold) {\n                        nval += brk.len;\n                    }\n                    else if (Additions.isInBreak(brk, nval)) {\n                        nval += brk.len;\n                    }\n                }\n            }\n            else if (val < threshold) {\n                for (const brk of breakArray) {\n                    if (brk.from > threshold) {\n                        // Skip all breaks above the threshold.\n                        break;\n                    }\n                    else if (brk.from >= nval && brk.from < threshold) {\n                        nval -= brk.len;\n                    }\n                    else if (Additions.isInBreak(brk, nval)) {\n                        nval -= brk.len;\n                    }\n                }\n            }\n            return nval;\n        }\n        /**\n         * @private\n         */\n        static val2Lin(val) {\n            const axis = this, threshold = axis.min || 0, brokenAxis = axis.brokenAxis, breakArray = brokenAxis?.breakArray;\n            if (!breakArray?.length || !isNumber(val)) {\n                return val;\n            }\n            let nval = val;\n            // Axis min is the anchor point. Above it, break gaps impact the\n            // result differently than below.\n            if (val > threshold) {\n                for (const brk of breakArray) {\n                    if (brk.to <= val && brk.to > threshold) {\n                        nval -= brk.len;\n                    }\n                    else if (brk.from > val) {\n                        // Skip all breaks after the val.\n                        break;\n                    }\n                    else if (Additions.isInBreak(brk, val)) {\n                        nval -= (val - brk.from);\n                        break;\n                    }\n                }\n            }\n            else if (val < threshold) {\n                for (const brk of breakArray) {\n                    if (brk.from >= val && brk.from < threshold) {\n                        nval += brk.len;\n                    }\n                    else if (brk.from > threshold) {\n                        // Skip all breaks before the threshold.\n                        break;\n                    }\n                    else if (Additions.isInBreak(brk, val)) {\n                        nval += (brk.to - val);\n                        break;\n                    }\n                }\n            }\n            return nval;\n        }\n        /* *\n         *\n         *  Constructors\n         *\n         * */\n        constructor(axis) {\n            this.axis = axis;\n        }\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Returns the first break found where the x is larger then break.from\n         * and smaller then break.to.\n         *\n         * @param {number} x\n         * The number which should be within a break.\n         *\n         * @param {Array<Highcharts.XAxisBreaksOptions>} breaks\n         * The array of breaks to search within.\n         *\n         * @return {Highcharts.XAxisBreaksOptions|undefined}\n         * Returns the first break found that matches, returns false if no break\n         * is found.\n         */\n        findBreakAt(x, breaks) {\n            return find(breaks, function (b) {\n                return b.from < x && x < b.to;\n            });\n        }\n        /**\n         * @private\n         */\n        isInAnyBreak(val, testKeep) {\n            const brokenAxis = this, axis = brokenAxis.axis, breaks = axis.options.breaks || [];\n            let i = breaks.length, inbrk, keep, ret;\n            if (i && isNumber(val)) {\n                while (i--) {\n                    if (Additions.isInBreak(breaks[i], val)) {\n                        inbrk = true;\n                        if (!keep) {\n                            keep = pick(breaks[i].showPoints, !axis.isXAxis);\n                        }\n                    }\n                }\n                if (inbrk && testKeep) {\n                    ret = inbrk && !keep;\n                }\n                else {\n                    ret = inbrk;\n                }\n            }\n            return ret;\n        }\n        /**\n         * Dynamically set or unset breaks in an axis. This function in lighter\n         * than using Axis.update, and it also preserves animation.\n         *\n         * @private\n         * @function Highcharts.Axis#setBreaks\n         *\n         * @param {Array<Highcharts.XAxisBreaksOptions>} [breaks]\n         * The breaks to add. When `undefined` it removes existing breaks.\n         *\n         * @param {boolean} [redraw=true]\n         * Whether to redraw the chart immediately.\n         */\n        setBreaks(breaks, redraw) {\n            const brokenAxis = this, axis = brokenAxis.axis, time = axis.chart.time, hasBreaks = isArray(breaks) &&\n                !!Object.keys(breaks?.[0] || {}).length;\n            axis.isDirty = (brokenAxis.hasBreaks ?? false) !== hasBreaks;\n            brokenAxis.hasBreaks = hasBreaks;\n            // Compile string dates\n            breaks?.forEach((brk) => {\n                brk.from = time.parse(brk.from) || 0;\n                brk.to = time.parse(brk.to) || 0;\n            });\n            if (breaks !== axis.options.breaks) {\n                axis.options.breaks = axis.userOptions.breaks = breaks;\n            }\n            axis.forceRedraw = true; // Force recalculation in setScale\n            // Recalculate series related to the axis.\n            axis.series.forEach(function (series) {\n                series.isDirty = true;\n            });\n            if (!hasBreaks && axis.val2lin === Additions.val2Lin) {\n                // Revert to prototype functions\n                delete axis.val2lin;\n                delete axis.lin2val;\n            }\n            if (hasBreaks) {\n                axis.userOptions.ordinal = false;\n                axis.lin2val = Additions.lin2Val;\n                axis.val2lin = Additions.val2Lin;\n                axis.setExtremes = function (newMin, newMax, redraw, animation, eventArguments) {\n                    // If trying to set extremes inside a break, extend min to\n                    // after, and max to before the break ( #3857 )\n                    // but not for gantt (#13898);\n                    if (brokenAxis.hasBreaks && !axis.treeGrid?.tree) {\n                        const breaks = (this.brokenAxis.breakArray || []);\n                        let axisBreak;\n                        while ((axisBreak = brokenAxis.findBreakAt(newMin, breaks))) {\n                            newMin = axisBreak.to;\n                        }\n                        while ((axisBreak = brokenAxis.findBreakAt(newMax, breaks))) {\n                            newMax = axisBreak.from;\n                        }\n                        // If both min and max is within the same break.\n                        if (newMax < newMin) {\n                            newMax = newMin;\n                        }\n                    }\n                    axis.constructor.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);\n                };\n                axis.setAxisTranslation = function () {\n                    axis.constructor.prototype.setAxisTranslation.call(this);\n                    brokenAxis.unitLength = void 0;\n                    if (brokenAxis.hasBreaks) {\n                        const breaks = axis.options.breaks || [], breakArrayTemp = [], breakArray = [], pointRangePadding = axis.pointRangePadding ?? 0;\n                        let length = 0, inBrk, repeat, min = axis.userMin ?? axis.min, max = axis.userMax ?? axis.max, dataMin = axis.dataMin ?? min, dataMax = axis.dataMax ?? max, start, i;\n                        if (isNumber(axis.threshold)) {\n                            dataMin = Math.min(dataMin ?? axis.threshold, axis.threshold);\n                            dataMax = Math.max(dataMax ?? axis.threshold, axis.threshold);\n                        }\n                        // Min & max check (#4247) but not for gantt (#13898)\n                        if (!axis.treeGrid?.tree) {\n                            breaks.forEach(function (brk) {\n                                repeat = brk.repeat || Infinity;\n                                if (isNumber(min) && isNumber(max)) {\n                                    if (Additions.isInBreak(brk, min)) {\n                                        min += ((brk.to % repeat) -\n                                            (min % repeat));\n                                    }\n                                    if (Additions.isInBreak(brk, max)) {\n                                        max -= ((max % repeat) -\n                                            (brk.from % repeat));\n                                    }\n                                }\n                            });\n                        }\n                        // Construct an array holding all breaks in the axis\n                        // for the current data range.\n                        if (isNumber(dataMin) && isNumber(dataMax)) {\n                            breaks.forEach(function (brk) {\n                                start = brk.from;\n                                repeat = brk.repeat || Infinity;\n                                while (start - repeat > dataMin) {\n                                    start -= repeat;\n                                }\n                                while (start < dataMin) {\n                                    start += repeat;\n                                }\n                                for (i = start; i < dataMax; i += repeat) {\n                                    breakArrayTemp.push({\n                                        value: i,\n                                        move: 'in'\n                                    });\n                                    breakArrayTemp.push({\n                                        value: i + brk.to - brk.from,\n                                        move: 'out',\n                                        size: brk.breakSize\n                                    });\n                                }\n                            });\n                        }\n                        breakArrayTemp.sort(function (a, b) {\n                            return ((a.value === b.value) ?\n                                ((a.move === 'in' ? 0 : 1) -\n                                    (b.move === 'in' ? 0 : 1)) :\n                                a.value - b.value);\n                        });\n                        // Simplify the breaks\n                        inBrk = 0;\n                        start = dataMin;\n                        breakArrayTemp.forEach((brk) => {\n                            inBrk += (brk.move === 'in' ? 1 : -1);\n                            if (inBrk === 1 && brk.move === 'in') {\n                                start = brk.value;\n                            }\n                            if (inBrk === 0 && isNumber(start)) {\n                                breakArray.push({\n                                    from: start,\n                                    to: brk.value,\n                                    len: brk.value - start - (brk.size || 0)\n                                });\n                                if (isNumber(min) && isNumber(max) &&\n                                    start < max && brk.value > min) {\n                                    // Sum break gaps in the visible range\n                                    length += (brk.value -\n                                        start -\n                                        (brk.size || 0));\n                                }\n                            }\n                        });\n                        brokenAxis.breakArray = breakArray;\n                        // Used with staticScale, and below the actual axis\n                        // length, when breaks are subtracted.\n                        if (isNumber(min) &&\n                            isNumber(max) &&\n                            isNumber(axis.min)) {\n                            brokenAxis.unitLength = max - min - length +\n                                pointRangePadding;\n                            fireEvent(axis, 'afterBreaks');\n                            if (axis.staticScale) {\n                                axis.transA = axis.staticScale;\n                            }\n                            else if (brokenAxis.unitLength) {\n                                axis.transA *=\n                                    (max - axis.min + pointRangePadding) /\n                                        brokenAxis.unitLength;\n                            }\n                            if (pointRangePadding) {\n                                axis.minPixelPadding =\n                                    axis.transA * (axis.minPointOffset || 0);\n                            }\n                            axis.min = min;\n                            axis.max = max;\n                        }\n                    }\n                };\n            }\n            if (pick(redraw, true)) {\n                axis.chart.redraw();\n            }\n        }\n    }\n    BrokenAxis.Additions = Additions;\n})(BrokenAxis || (BrokenAxis = {}));\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Axis_BrokenAxis = (BrokenAxis);\n\n;// ./code/es-modules/masters/modules/broken-axis.js\n\n\n\n\nconst G = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\nG.BrokenAxis = G.BrokenAxis || Axis_BrokenAxis;\nG.BrokenAxis.compose(G.Axis, G.Series);\n/* harmony default export */ const broken_axis_src = ((highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()));\n\n__webpack_exports__ = __webpack_exports__[\"default\"];\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});"],"names":["root","factory","exports","module","define","amd","amd1","window","__WEBPACK_EXTERNAL_MODULE__944__","__WEBPACK_EXTERNAL_MODULE__184__","BrokenAxis","__webpack_modules__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","__webpack_exports__","broken_axis_src","highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_","highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default","highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_","highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_default","addEvent","find","fireEvent","isArray","isNumber","pick","onAxisAfterInit","brokenAxis","setBreaks","options","breaks","onAxisAfterSetOptions","keys","axis","length","ordinal","onAxisAfterSetTickPositions","hasBreaks","tickPositions","info","newPositions","i","isInAnyBreak","push","onAxisInit","Additions","onSeriesAfterGeneratePoints","isDirty","connectNulls","points","xAxis","yAxis","point","isPointInBreak","y","x","visible","onSeriesAfterRender","drawBreaks","pointArrayMap","seriesDrawBreaks","threshold","series","forEach","breakArray","isXAxis","min","toUpperCase","brk","eventName","from","to","seriesGappedPath","currentDataGrouping","groupingSize","gapSize","slice","current","next","gapUnit","basePointRange","xRange","splice","isNull","stacking","stack","stacks","stackKey","stackLabels","total","getGraphPath","compose","AxisClass","SeriesClass","keepProps","includes","seriesProto","gappedPath","isInBreak","val","ret","repeat","Infinity","test","inclusive","lin2Val","nval","len","val2Lin","constructor","findBreakAt","b","testKeep","inbrk","keep","showPoints","redraw","time","chart","parse","userOptions","forceRedraw","val2lin","lin2val","setExtremes","newMin","newMax","animation","eventArguments","treeGrid","tree","axisBreak","setAxisTranslation","unitLength","breakArrayTemp","pointRangePadding","inBrk","userMin","max","userMax","dataMin","dataMax","start","Math","value","move","size","breakSize","sort","staticScale","transA","minPixelPadding","minPointOffset","Axis_BrokenAxis","G","Axis","Series"],"mappings":"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"}