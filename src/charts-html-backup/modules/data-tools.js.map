{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v12.4.0 (2025-09-04)\n * @module highcharts/modules/data-tools\n * @requires highcharts\n *\n * Highcharts\n *\n * (c) 2010-2025 Highsoft AS\n *\n * License: www.highcharts.com/license\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(root[\"_Highcharts\"]);\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"highcharts/modules/data-tools\", [\"highcharts/highcharts\"], function (amd1) {return factory(amd1);});\n\telse if(typeof exports === 'object')\n\t\texports[\"highcharts/modules/data-tools\"] = factory(root[\"_Highcharts\"]);\n\telse\n\t\troot[\"Highcharts\"] = factory(root[\"Highcharts\"]);\n})(typeof window === 'undefined' ? this : window, (__WEBPACK_EXTERNAL_MODULE__944__) => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 944:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__944__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__webpack_require__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ data_tools_src)\n});\n\n// EXTERNAL MODULE: external {\"amd\":[\"highcharts/highcharts\"],\"commonjs\":[\"highcharts\"],\"commonjs2\":[\"highcharts\"],\"root\":[\"Highcharts\"]}\nvar highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_ = __webpack_require__(944);\nvar highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default = /*#__PURE__*/__webpack_require__.n(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_);\n;// ./code/es-modules/Data/Modifiers/DataModifier.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *  - GÃ¸ran Slettemark\n *\n * */\n\n\nconst { addEvent, fireEvent, merge } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Abstract class to provide an interface for modifying a table.\n *\n */\nclass DataModifier {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Runs a timed execution of the modifier on the given datatable.\n     * Can be configured to run multiple times.\n     *\n     * @param {DataTable} dataTable\n     * The datatable to execute\n     *\n     * @param {DataModifier.BenchmarkOptions} options\n     * Options. Currently supports `iterations` for number of iterations.\n     *\n     * @return {Array<number>}\n     * An array of times in milliseconds\n     *\n     */\n    benchmark(dataTable, options) {\n        const results = [];\n        const modifier = this;\n        const execute = () => {\n            modifier.modifyTable(dataTable);\n            modifier.emit({\n                type: 'afterBenchmarkIteration'\n            });\n        };\n        const defaultOptions = {\n            iterations: 1\n        };\n        const { iterations } = merge(defaultOptions, options);\n        modifier.on('afterBenchmarkIteration', () => {\n            if (results.length === iterations) {\n                modifier.emit({\n                    type: 'afterBenchmark',\n                    results\n                });\n                return;\n            }\n            // Run again\n            execute();\n        });\n        const times = {\n            startTime: 0,\n            endTime: 0\n        };\n        // Add timers\n        modifier.on('modify', () => {\n            times.startTime = window.performance.now();\n        });\n        modifier.on('afterModify', () => {\n            times.endTime = window.performance.now();\n            results.push(times.endTime - times.startTime);\n        });\n        // Initial run\n        execute();\n        return results;\n    }\n    /**\n     * Emits an event on the modifier to all registered callbacks of this event.\n     *\n     * @param {DataModifier.Event} [e]\n     * Event object containing additonal event information.\n     */\n    emit(e) {\n        fireEvent(this, e.type, e);\n    }\n    /**\n     * Returns a modified copy of the given table.\n     *\n     * @param {Highcharts.DataTable} table\n     * Table to modify.\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Promise<Highcharts.DataTable>}\n     * Table with `modified` property as a reference.\n     */\n    modify(table, eventDetail) {\n        const modifier = this;\n        return new Promise((resolve, reject) => {\n            if (table.modified === table) {\n                table.modified = table.clone(false, eventDetail);\n            }\n            try {\n                resolve(modifier.modifyTable(table, eventDetail));\n            }\n            catch (e) {\n                modifier.emit({\n                    type: 'error',\n                    detail: eventDetail,\n                    table\n                });\n                reject(e instanceof Error ? e : new Error('' + e));\n            }\n        });\n    }\n    /**\n     * Applies partial modifications of a cell change to the property `modified`\n     * of the given modified table.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {string} columnName\n     * Column name of changed cell.\n     *\n     * @param {number|undefined} rowIndex\n     * Row index of changed cell.\n     *\n     * @param {Highcharts.DataTableCellType} cellValue\n     * Changed cell value.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyCell(table, \n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    columnName, rowIndex, cellValue, eventDetail\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n    ) {\n        return this.modifyTable(table);\n    }\n    /**\n     * Applies partial modifications of column changes to the property\n     * `modified` of the given table.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {Highcharts.DataTableColumnCollection} columns\n     * Changed columns as a collection, where the keys are the column names.\n     *\n     * @param {number} [rowIndex=0]\n     * Index of the first changed row.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyColumns(table, \n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    columns, rowIndex, eventDetail\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n    ) {\n        return this.modifyTable(table);\n    }\n    /**\n     * Applies partial modifications of row changes to the property `modified`\n     * of the given table.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {Array<(Highcharts.DataTableRow|Highcharts.DataTableRowObject)>} rows\n     * Changed rows.\n     *\n     * @param {number} [rowIndex]\n     * Index of the first changed row.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyRows(table, \n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    rows, rowIndex, eventDetail\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n    ) {\n        return this.modifyTable(table);\n    }\n    /**\n     * Registers a callback for a specific modifier event.\n     *\n     * @param {string} type\n     * Event type as a string.\n     *\n     * @param {DataEventEmitter.Callback} callback\n     * Function to register for an modifier callback.\n     *\n     * @return {Function}\n     * Function to unregister callback from the modifier event.\n     */\n    on(type, callback) {\n        return addEvent(this, type, callback);\n    }\n}\n/* *\n *\n *  Class Namespace\n *\n * */\n/**\n * Additionally provided types for modifier events and options.\n */\n(function (DataModifier) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Constants\n     *\n     * */\n    /**\n     * Registry as a record object with modifier names and their class\n     * constructor.\n     */\n    DataModifier.types = {};\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Adds a modifier class to the registry. The modifier class has to provide\n     * the `DataModifier.options` property and the `DataModifier.modifyTable`\n     * method to modify the table.\n     *\n     * @private\n     *\n     * @param {string} key\n     * Registry key of the modifier class.\n     *\n     * @param {DataModifierType} DataModifierClass\n     * Modifier class (aka class constructor) to register.\n     *\n     * @return {boolean}\n     * Returns true, if the registration was successful. False is returned, if\n     * their is already a modifier registered with this key.\n     */\n    function registerType(key, DataModifierClass) {\n        return (!!key &&\n            !DataModifier.types[key] &&\n            !!(DataModifier.types[key] = DataModifierClass));\n    }\n    DataModifier.registerType = registerType;\n})(DataModifier || (DataModifier = {}));\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Modifiers_DataModifier = (DataModifier);\n\n;// ./code/es-modules/Data/ColumnUtils.js\n/* *\n *\n *  (c) 2020-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Dawid Dragula\n *\n * */\n/**\n * Utility functions for columns that can be either arrays or typed arrays.\n * @private\n */\nvar ColumnUtils;\n(function (ColumnUtils) {\n    /* *\n    *\n    *  Declarations\n    *\n    * */\n    /* *\n    *\n    * Functions\n    *\n    * */\n    /**\n     * Sets the length of the column array.\n     *\n     * @param {DataTable.Column} column\n     * Column to be modified.\n     *\n     * @param {number} length\n     * New length of the column.\n     *\n     * @param {boolean} asSubarray\n     * If column is a typed array, return a subarray instead of a new array. It\n     * is faster `O(1)`, but the entire buffer will be kept in memory until all\n     * views to it are destroyed. Default is `false`.\n     *\n     * @return {DataTable.Column}\n     * Modified column.\n     *\n     * @private\n     */\n    function setLength(column, length, asSubarray) {\n        if (Array.isArray(column)) {\n            column.length = length;\n            return column;\n        }\n        return column[asSubarray ? 'subarray' : 'slice'](0, length);\n    }\n    ColumnUtils.setLength = setLength;\n    /**\n     * Splices a column array.\n     *\n     * @param {DataTable.Column} column\n     * Column to be modified.\n     *\n     * @param {number} start\n     * Index at which to start changing the array.\n     *\n     * @param {number} deleteCount\n     * An integer indicating the number of old array elements to remove.\n     *\n     * @param {boolean} removedAsSubarray\n     * If column is a typed array, return a subarray instead of a new array. It\n     * is faster `O(1)`, but the entire buffer will be kept in memory until all\n     * views to it are destroyed. Default is `true`.\n     *\n     * @param {Array<number>|TypedArray} items\n     * The elements to add to the array, beginning at the start index. If you\n     * don't specify any elements, `splice()` will only remove elements from the\n     * array.\n     *\n     * @return {SpliceResult}\n     * Object containing removed elements and the modified column.\n     *\n     * @private\n     */\n    function splice(column, start, deleteCount, removedAsSubarray, items = []) {\n        if (Array.isArray(column)) {\n            if (!Array.isArray(items)) {\n                items = Array.from(items);\n            }\n            return {\n                removed: column.splice(start, deleteCount, ...items),\n                array: column\n            };\n        }\n        const Constructor = Object.getPrototypeOf(column)\n            .constructor;\n        const removed = column[removedAsSubarray ? 'subarray' : 'slice'](start, start + deleteCount);\n        const newLength = column.length - deleteCount + items.length;\n        const result = new Constructor(newLength);\n        result.set(column.subarray(0, start), 0);\n        result.set(items, start);\n        result.set(column.subarray(start + deleteCount), start + items.length);\n        return {\n            removed: removed,\n            array: result\n        };\n    }\n    ColumnUtils.splice = splice;\n})(ColumnUtils || (ColumnUtils = {}));\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Data_ColumnUtils = (ColumnUtils);\n\n;// ./code/es-modules/Data/DataTableCore.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *  - GÃ¸ran Slettemark\n *  - Torstein HÃ¸nsi\n *\n * */\n\n\nconst { setLength, splice } = Data_ColumnUtils;\n\nconst { fireEvent: DataTableCore_fireEvent, objectEach, uniqueKey } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Class to manage columns and rows in a table structure. It provides methods\n * to add, remove, and manipulate columns and rows, as well as to retrieve data\n * from specific cells.\n *\n * @class\n * @name Highcharts.DataTable\n *\n * @param {Highcharts.DataTableOptions} [options]\n * Options to initialize the new DataTable instance.\n */\nclass DataTableCore {\n    /**\n     * Constructs an instance of the DataTable class.\n     *\n     * @example\n     * const dataTable = new Highcharts.DataTableCore({\n     *   columns: {\n     *     year: [2020, 2021, 2022, 2023],\n     *     cost: [11, 13, 12, 14],\n     *     revenue: [12, 15, 14, 18]\n     *   }\n     * });\n\n     *\n     * @param {Highcharts.DataTableOptions} [options]\n     * Options to initialize the new DataTable instance.\n     */\n    constructor(options = {}) {\n        /**\n         * Whether the ID was automatic generated or given in the constructor.\n         *\n         * @name Highcharts.DataTable#autoId\n         * @type {boolean}\n         */\n        this.autoId = !options.id;\n        this.columns = {};\n        /**\n         * ID of the table for identification purposes.\n         *\n         * @name Highcharts.DataTable#id\n         * @type {string}\n         */\n        this.id = (options.id || uniqueKey());\n        this.modified = this;\n        this.rowCount = 0;\n        this.versionTag = uniqueKey();\n        let rowCount = 0;\n        objectEach(options.columns || {}, (column, columnName) => {\n            this.columns[columnName] = column.slice();\n            rowCount = Math.max(rowCount, column.length);\n        });\n        this.applyRowCount(rowCount);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Applies a row count to the table by setting the `rowCount` property and\n     * adjusting the length of all columns.\n     *\n     * @private\n     * @param {number} rowCount The new row count.\n     */\n    applyRowCount(rowCount) {\n        this.rowCount = rowCount;\n        objectEach(this.columns, (column, columnName) => {\n            if (column.length !== rowCount) {\n                this.columns[columnName] = setLength(column, rowCount);\n            }\n        });\n    }\n    /**\n     * Delete rows. Simplified version of the full\n     * `DataTable.deleteRows` method.\n     *\n     * @param {number} rowIndex\n     * The start row index\n     *\n     * @param {number} [rowCount=1]\n     * The number of rows to delete\n     *\n     * @return {void}\n     *\n     * @emits #afterDeleteRows\n     */\n    deleteRows(rowIndex, rowCount = 1) {\n        if (rowCount > 0 && rowIndex < this.rowCount) {\n            let length = 0;\n            objectEach(this.columns, (column, columnName) => {\n                this.columns[columnName] =\n                    splice(column, rowIndex, rowCount).array;\n                length = column.length;\n            });\n            this.rowCount = length;\n        }\n        DataTableCore_fireEvent(this, 'afterDeleteRows', { rowIndex, rowCount });\n        this.versionTag = uniqueKey();\n    }\n    /**\n     * Fetches the given column by the canonical column name. Simplified version\n     * of the full `DataTable.getRow` method, always returning by reference.\n     *\n     * @param {string} columnName\n     * Name of the column to get.\n     *\n     * @return {Highcharts.DataTableColumn|undefined}\n     * A copy of the column, or `undefined` if not found.\n     */\n    getColumn(columnName, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    asReference) {\n        return this.columns[columnName];\n    }\n    /**\n     * Retrieves all or the given columns. Simplified version of the full\n     * `DataTable.getColumns` method, always returning by reference.\n     *\n     * @param {Array<string>} [columnNames]\n     * Column names to retrieve.\n     *\n     * @return {Highcharts.DataTableColumnCollection}\n     * Collection of columns. If a requested column was not found, it is\n     * `undefined`.\n     */\n    getColumns(columnNames, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    asReference) {\n        return (columnNames || Object.keys(this.columns)).reduce((columns, columnName) => {\n            columns[columnName] = this.columns[columnName];\n            return columns;\n        }, {});\n    }\n    /**\n     * Retrieves the row at a given index.\n     *\n     * @param {number} rowIndex\n     * Row index to retrieve. First row has index 0.\n     *\n     * @param {Array<string>} [columnNames]\n     * Column names to retrieve.\n     *\n     * @return {Record<string, number|string|undefined>|undefined}\n     * Returns the row values, or `undefined` if not found.\n     */\n    getRow(rowIndex, columnNames) {\n        return (columnNames || Object.keys(this.columns)).map((key) => this.columns[key]?.[rowIndex]);\n    }\n    /**\n     * Sets cell values for a column. Will insert a new column, if not found.\n     *\n     * @param {string} columnName\n     * Column name to set.\n     *\n     * @param {Highcharts.DataTableColumn} [column]\n     * Values to set in the column.\n     *\n     * @param {number} [rowIndex]\n     * Index of the first row to change. (Default: 0)\n     *\n     * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #setColumns\n     * @emits #afterSetColumns\n     */\n    setColumn(columnName, column = [], rowIndex = 0, eventDetail) {\n        this.setColumns({ [columnName]: column }, rowIndex, eventDetail);\n    }\n    /**\n     * Sets cell values for multiple columns. Will insert new columns, if not\n     * found. Simplified version of the full `DataTableCore.setColumns`, limited\n     * to full replacement of the columns (undefined `rowIndex`).\n     *\n     * @param {Highcharts.DataTableColumnCollection} columns\n     * Columns as a collection, where the keys are the column names.\n     *\n     * @param {number} [rowIndex]\n     * Index of the first row to change. Ignored in the `DataTableCore`, as it\n     * always replaces the full column.\n     *\n     * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #setColumns\n     * @emits #afterSetColumns\n     */\n    setColumns(columns, rowIndex, eventDetail) {\n        let rowCount = this.rowCount;\n        objectEach(columns, (column, columnName) => {\n            this.columns[columnName] = column.slice();\n            rowCount = column.length;\n        });\n        this.applyRowCount(rowCount);\n        if (!eventDetail?.silent) {\n            DataTableCore_fireEvent(this, 'afterSetColumns');\n            this.versionTag = uniqueKey();\n        }\n    }\n    /**\n     * Sets cell values of a row. Will insert a new row if no index was\n     * provided, or if the index is higher than the total number of table rows.\n     * A simplified version of the full `DateTable.setRow`, limited to objects.\n     *\n     * @param {Record<string, number|string|undefined>} row\n     * Cell values to set.\n     *\n     * @param {number} [rowIndex]\n     * Index of the row to set. Leave `undefined` to add as a new row.\n     *\n     * @param {boolean} [insert]\n     * Whether to insert the row at the given index, or to overwrite the row.\n     *\n     * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #afterSetRows\n     */\n    setRow(row, rowIndex = this.rowCount, insert, eventDetail) {\n        const { columns } = this, indexRowCount = insert ? this.rowCount + 1 : rowIndex + 1;\n        objectEach(row, (cellValue, columnName) => {\n            let column = columns[columnName] ||\n                eventDetail?.addColumns !== false && new Array(indexRowCount);\n            if (column) {\n                if (insert) {\n                    column = splice(column, rowIndex, 0, true, [cellValue]).array;\n                }\n                else {\n                    column[rowIndex] = cellValue;\n                }\n                columns[columnName] = column;\n            }\n        });\n        if (indexRowCount > this.rowCount) {\n            this.applyRowCount(indexRowCount);\n        }\n        if (!eventDetail?.silent) {\n            DataTableCore_fireEvent(this, 'afterSetRows');\n            this.versionTag = uniqueKey();\n        }\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Data_DataTableCore = (DataTableCore);\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * A typed array.\n * @typedef {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} Highcharts.TypedArray\n * //**\n * A column of values in a data table.\n * @typedef {Array<boolean|null|number|string|undefined>|Highcharts.TypedArray} Highcharts.DataTableColumn\n */ /**\n* A collection of data table columns defined by a object where the key is the\n* column name and the value is an array of the column values.\n* @typedef {Record<string, Highcharts.DataTableColumn>} Highcharts.DataTableColumnCollection\n*/\n/**\n * Options for the `DataTable` or `DataTableCore` classes.\n * @interface Highcharts.DataTableOptions\n */ /**\n* The column options for the data table. The columns are defined by an object\n* where the key is the column ID and the value is an array of the column\n* values.\n*\n* @name Highcharts.DataTableOptions.columns\n* @type {Highcharts.DataTableColumnCollection|undefined}\n*/ /**\n* Custom ID to identify the new DataTable instance.\n*\n* @name Highcharts.DataTableOptions.id\n* @type {string|undefined}\n*/\n(''); // Keeps doclets above in JS file\n\n;// ./code/es-modules/Data/DataTable.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *  - GÃ¸ran Slettemark\n *  - Jomar HÃ¸nsi\n *  - Dawid Dragula\n *\n * */\n\n\n\n\nconst { addEvent: DataTable_addEvent, defined, extend, fireEvent: DataTable_fireEvent, isNumber, uniqueKey: DataTable_uniqueKey } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Class to manage columns and rows in a table structure. It provides methods\n * to add, remove, and manipulate columns and rows, as well as to retrieve data\n * from specific cells.\n *\n * @class\n * @name Highcharts.DataTable\n *\n * @param {Highcharts.DataTableOptions} [options]\n * Options to initialize the new DataTable instance.\n */\nclass DataTable extends Data_DataTableCore {\n    /* *\n     *\n     *  Static Functions\n     *\n     * */\n    /**\n     * Tests whether a row contains only `null` values or is equal to\n     * DataTable.NULL. If all columns have `null` values, the function returns\n     * `true`. Otherwise, it returns `false` to indicate that the row contains\n     * at least one non-null value.\n     *\n     * @function Highcharts.DataTable.isNull\n     *\n     * @param {Highcharts.DataTableRow|Highcharts.DataTableRowObject} row\n     * Row to test.\n     *\n     * @return {boolean}\n     * Returns `true`, if the row contains only null, otherwise `false`.\n     *\n     * @example\n     * if (DataTable.isNull(row)) {\n     *   // handle null row\n     * }\n     */\n    static isNull(row) {\n        if (row === DataTable.NULL) {\n            return true;\n        }\n        if (row instanceof Array) {\n            if (!row.length) {\n                return false;\n            }\n            for (let i = 0, iEnd = row.length; i < iEnd; ++i) {\n                if (row[i] !== null) {\n                    return false;\n                }\n            }\n        }\n        else {\n            const columnNames = Object.keys(row);\n            if (!columnNames.length) {\n                return false;\n            }\n            for (let i = 0, iEnd = columnNames.length; i < iEnd; ++i) {\n                if (row[columnNames[i]] !== null) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    constructor(options = {}) {\n        super(options);\n        this.modified = this;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Returns a clone of this table. The cloned table is completely independent\n     * of the original, and any changes made to the clone will not affect\n     * the original table.\n     *\n     * @function Highcharts.DataTable#clone\n     *\n     * @param {boolean} [skipColumns]\n     * Whether to clone columns or not.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Clone of this data table.\n     *\n     * @emits #cloneTable\n     * @emits #afterCloneTable\n     */\n    clone(skipColumns, eventDetail) {\n        const table = this, tableOptions = {};\n        table.emit({ type: 'cloneTable', detail: eventDetail });\n        if (!skipColumns) {\n            tableOptions.columns = table.columns;\n        }\n        if (!table.autoId) {\n            tableOptions.id = table.id;\n        }\n        const tableClone = new DataTable(tableOptions);\n        if (!skipColumns) {\n            tableClone.versionTag = table.versionTag;\n            tableClone.originalRowIndexes = table.originalRowIndexes;\n            tableClone.localRowIndexes = table.localRowIndexes;\n        }\n        table.emit({\n            type: 'afterCloneTable',\n            detail: eventDetail,\n            tableClone\n        });\n        return tableClone;\n    }\n    /**\n     * Deletes columns from the table.\n     *\n     * @function Highcharts.DataTable#deleteColumns\n     *\n     * @param {Array<string>} [columnNames]\n     * Names of columns to delete. If no array is provided, all\n     * columns will be deleted.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTableColumnCollection|undefined}\n     * Returns the deleted columns, if found.\n     *\n     * @emits #deleteColumns\n     * @emits #afterDeleteColumns\n     */\n    deleteColumns(columnNames, eventDetail) {\n        const table = this, columns = table.columns, deletedColumns = {}, modifiedColumns = {}, modifier = table.modifier, rowCount = table.rowCount;\n        columnNames = (columnNames || Object.keys(columns));\n        if (columnNames.length) {\n            table.emit({\n                type: 'deleteColumns',\n                columnNames,\n                detail: eventDetail\n            });\n            for (let i = 0, iEnd = columnNames.length, column, columnName; i < iEnd; ++i) {\n                columnName = columnNames[i];\n                column = columns[columnName];\n                if (column) {\n                    deletedColumns[columnName] = column;\n                    modifiedColumns[columnName] = new Array(rowCount);\n                }\n                delete columns[columnName];\n            }\n            if (!Object.keys(columns).length) {\n                table.rowCount = 0;\n                this.deleteRowIndexReferences();\n            }\n            if (modifier) {\n                modifier.modifyColumns(table, modifiedColumns, 0, eventDetail);\n            }\n            table.emit({\n                type: 'afterDeleteColumns',\n                columns: deletedColumns,\n                columnNames,\n                detail: eventDetail\n            });\n            return deletedColumns;\n        }\n    }\n    /**\n     * Deletes the row index references. This is useful when the original table\n     * is deleted, and the references are no longer needed. This table is\n     * then considered an original table or a table that has the same row's\n     * order as the original table.\n     */\n    deleteRowIndexReferences() {\n        delete this.originalRowIndexes;\n        delete this.localRowIndexes;\n        // Here, in case of future need, can be implemented updating of the\n        // modified tables' row indexes references.\n    }\n    /**\n     * Deletes rows in this table.\n     *\n     * @function Highcharts.DataTable#deleteRows\n     *\n     * @param {number} [rowIndex]\n     * Index to start delete of rows. If not specified, all rows will be\n     * deleted.\n     *\n     * @param {number} [rowCount=1]\n     * Number of rows to delete.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Array<Highcharts.DataTableRow>}\n     * Returns the deleted rows, if found.\n     *\n     * @emits #deleteRows\n     * @emits #afterDeleteRows\n     */\n    deleteRows(rowIndex, rowCount = 1, eventDetail) {\n        const table = this, deletedRows = [], modifiedRows = [], modifier = table.modifier;\n        table.emit({\n            type: 'deleteRows',\n            detail: eventDetail,\n            rowCount,\n            rowIndex: (rowIndex || 0)\n        });\n        if (typeof rowIndex === 'undefined') {\n            rowIndex = 0;\n            rowCount = table.rowCount;\n        }\n        if (rowCount > 0 && rowIndex < table.rowCount) {\n            const columns = table.columns, columnNames = Object.keys(columns);\n            for (let i = 0, iEnd = columnNames.length, column, deletedCells, columnName; i < iEnd; ++i) {\n                columnName = columnNames[i];\n                column = columns[columnName];\n                const result = Data_ColumnUtils.splice(column, rowIndex, rowCount);\n                deletedCells = result.removed;\n                columns[columnName] = column = result.array;\n                if (!i) {\n                    table.rowCount = column.length;\n                }\n                for (let j = 0, jEnd = deletedCells.length; j < jEnd; ++j) {\n                    deletedRows[j] = (deletedRows[j] || []);\n                    deletedRows[j][i] = deletedCells[j];\n                }\n                modifiedRows.push(new Array(iEnd));\n            }\n        }\n        if (modifier) {\n            modifier.modifyRows(table, modifiedRows, (rowIndex || 0), eventDetail);\n        }\n        table.emit({\n            type: 'afterDeleteRows',\n            detail: eventDetail,\n            rowCount,\n            rowIndex: (rowIndex || 0),\n            rows: deletedRows\n        });\n        return deletedRows;\n    }\n    /**\n     * Emits an event on this table to all registered callbacks of the given\n     * event.\n     * @private\n     *\n     * @param {DataTable.Event} e\n     * Event object with event information.\n     */\n    emit(e) {\n        if ([\n            'afterDeleteColumns',\n            'afterDeleteRows',\n            'afterSetCell',\n            'afterSetColumns',\n            'afterSetRows'\n        ].includes(e.type)) {\n            this.versionTag = DataTable_uniqueKey();\n        }\n        DataTable_fireEvent(this, e.type, e);\n    }\n    /**\n     * Fetches a single cell value.\n     *\n     * @function Highcharts.DataTable#getCell\n     *\n     * @param {string} columnName\n     * Column name of the cell to retrieve.\n     *\n     * @param {number} rowIndex\n     * Row index of the cell to retrieve.\n     *\n     * @return {Highcharts.DataTableCellType|undefined}\n     * Returns the cell value or `undefined`.\n     */\n    getCell(columnName, rowIndex) {\n        const table = this;\n        const column = table.columns[columnName];\n        if (column) {\n            return column[rowIndex];\n        }\n    }\n    /**\n     * Fetches a cell value for the given row as a boolean.\n     *\n     * @function Highcharts.DataTable#getCellAsBoolean\n     *\n     * @param {string} columnName\n     * Column name to fetch.\n     *\n     * @param {number} rowIndex\n     * Row index to fetch.\n     *\n     * @return {boolean}\n     * Returns the cell value of the row as a boolean.\n     */\n    getCellAsBoolean(columnName, rowIndex) {\n        const table = this;\n        const column = table.columns[columnName];\n        return !!(column && column[rowIndex]);\n    }\n    /**\n     * Fetches a cell value for the given row as a number.\n     *\n     * @function Highcharts.DataTable#getCellAsNumber\n     *\n     * @param {string} columnName\n     * Column name or to fetch.\n     *\n     * @param {number} rowIndex\n     * Row index to fetch.\n     *\n     * @param {boolean} [useNaN]\n     * Whether to return NaN instead of `null` and `undefined`.\n     *\n     * @return {number|null}\n     * Returns the cell value of the row as a number.\n     */\n    getCellAsNumber(columnName, rowIndex, useNaN) {\n        const table = this;\n        const column = table.columns[columnName];\n        let cellValue = (column && column[rowIndex]);\n        switch (typeof cellValue) {\n            case 'boolean':\n                return (cellValue ? 1 : 0);\n            case 'number':\n                return (isNaN(cellValue) && !useNaN ? null : cellValue);\n        }\n        cellValue = parseFloat(`${cellValue ?? ''}`);\n        return (isNaN(cellValue) && !useNaN ? null : cellValue);\n    }\n    /**\n     * Fetches a cell value for the given row as a string.\n     *\n     * @function Highcharts.DataTable#getCellAsString\n     *\n     * @param {string} columnName\n     * Column name to fetch.\n     *\n     * @param {number} rowIndex\n     * Row index to fetch.\n     *\n     * @return {string}\n     * Returns the cell value of the row as a string.\n     */\n    getCellAsString(columnName, rowIndex) {\n        const table = this;\n        const column = table.columns[columnName];\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        return `${(column && column[rowIndex])}`;\n    }\n    /**\n     * Fetches the given column by the canonical column name.\n     * This function is a simplified wrap of {@link getColumns}.\n     *\n     * @function Highcharts.DataTable#getColumn\n     *\n     * @param {string} columnName\n     * Name of the column to get.\n     *\n     * @param {boolean} [asReference]\n     * Whether to return the column as a readonly reference.\n     *\n     * @return {Highcharts.DataTableColumn|undefined}\n     * A copy of the column, or `undefined` if not found.\n     */\n    getColumn(columnName, asReference) {\n        return this.getColumns([columnName], asReference)[columnName];\n    }\n    /**\n     * Fetches the given column by the canonical column name, and\n     * validates the type of the first few cells. If the first defined cell is\n     * of type number, it assumes for performance reasons, that all cells are of\n     * type number or `null`. Otherwise it will convert all cells to number\n     * type, except `null`.\n     *\n     * @deprecated\n     *\n     * @function Highcharts.DataTable#getColumnAsNumbers\n     *\n     * @param {string} columnName\n     * Name of the column to get.\n     *\n     * @param {boolean} [useNaN]\n     * Whether to use NaN instead of `null` and `undefined`.\n     *\n     * @return {Array<(number|null)>}\n     * A copy of the column, or an empty array if not found.\n     */\n    getColumnAsNumbers(columnName, useNaN) {\n        const table = this, columns = table.columns;\n        const column = columns[columnName], columnAsNumber = [];\n        if (column) {\n            const columnLength = column.length;\n            if (useNaN) {\n                for (let i = 0; i < columnLength; ++i) {\n                    columnAsNumber.push(table.getCellAsNumber(columnName, i, true));\n                }\n            }\n            else {\n                for (let i = 0, cellValue; i < columnLength; ++i) {\n                    cellValue = column[i];\n                    if (typeof cellValue === 'number') {\n                        // Assume unmixed data for performance reasons\n                        return column.slice();\n                    }\n                    if (cellValue !== null &&\n                        typeof cellValue !== 'undefined') {\n                        break;\n                    }\n                }\n                for (let i = 0; i < columnLength; ++i) {\n                    columnAsNumber.push(table.getCellAsNumber(columnName, i));\n                }\n            }\n        }\n        return columnAsNumber;\n    }\n    /**\n     * Fetches all column names.\n     *\n     * @function Highcharts.DataTable#getColumnNames\n     *\n     * @return {Array<string>}\n     * Returns all column names.\n     */\n    getColumnNames() {\n        return Object.keys(this.columns);\n    }\n    /**\n     * Retrieves all or the given columns.\n     *\n     * @function Highcharts.DataTable#getColumns\n     *\n     * @param {Array<string>} [columnNames]\n     * Column names to retrieve.\n     *\n     * @param {boolean} [asReference]\n     * Whether to return columns as a readonly reference.\n     *\n     * @param {boolean} [asBasicColumns]\n     * Whether to transform all typed array columns to normal arrays.\n     *\n     * @return {Highcharts.DataTableColumnCollection}\n     * Collection of columns. If a requested column was not found, it is\n     * `undefined`.\n     */\n    getColumns(columnNames, asReference, asBasicColumns) {\n        const table = this, tableColumns = table.columns, columns = {};\n        columnNames = (columnNames || Object.keys(tableColumns));\n        for (let i = 0, iEnd = columnNames.length, column, columnName; i < iEnd; ++i) {\n            columnName = columnNames[i];\n            column = tableColumns[columnName];\n            if (column) {\n                if (asReference) {\n                    columns[columnName] = column;\n                }\n                else if (asBasicColumns && !Array.isArray(column)) {\n                    columns[columnName] = Array.from(column);\n                }\n                else {\n                    columns[columnName] = column.slice();\n                }\n            }\n        }\n        return columns;\n    }\n    /**\n     * Takes the original row index and returns the local row index in the\n     * modified table for which this function is called.\n     *\n     * @param {number} originalRowIndex\n     * Original row index to get the local row index for.\n     *\n     * @return {number|undefined}\n     * Returns the local row index or `undefined` if not found.\n     */\n    getLocalRowIndex(originalRowIndex) {\n        const { localRowIndexes } = this;\n        if (localRowIndexes) {\n            return localRowIndexes[originalRowIndex];\n        }\n        return originalRowIndex;\n    }\n    /**\n     * Retrieves the modifier for the table.\n     * @private\n     *\n     * @return {Highcharts.DataModifier|undefined}\n     * Returns the modifier or `undefined`.\n     */\n    getModifier() {\n        return this.modifier;\n    }\n    /**\n     * Takes the local row index and returns the index of the corresponding row\n     * in the original table.\n     *\n     * @param {number} rowIndex\n     * Local row index to get the original row index for.\n     *\n     * @return {number|undefined}\n     * Returns the original row index or `undefined` if not found.\n     */\n    getOriginalRowIndex(rowIndex) {\n        const { originalRowIndexes } = this;\n        if (originalRowIndexes) {\n            return originalRowIndexes[rowIndex];\n        }\n        return rowIndex;\n    }\n    /**\n     * Retrieves the row at a given index. This function is a simplified wrap of\n     * {@link getRows}.\n     *\n     * @function Highcharts.DataTable#getRow\n     *\n     * @param {number} rowIndex\n     * Row index to retrieve. First row has index 0.\n     *\n     * @param {Array<string>} [columnNames]\n     * Column names in order to retrieve.\n     *\n     * @return {Highcharts.DataTableRow}\n     * Returns the row values, or `undefined` if not found.\n     */\n    getRow(rowIndex, columnNames) {\n        return this.getRows(rowIndex, 1, columnNames)[0];\n    }\n    /**\n     * Returns the number of rows in this table.\n     *\n     * @function Highcharts.DataTable#getRowCount\n     *\n     * @return {number}\n     * Number of rows in this table.\n     */\n    getRowCount() {\n        // @todo Implement via property getter `.length` browsers supported\n        return this.rowCount;\n    }\n    /**\n     * Retrieves the index of the first row matching a specific cell value.\n     *\n     * @function Highcharts.DataTable#getRowIndexBy\n     *\n     * @param {string} columnName\n     * Column to search in.\n     *\n     * @param {Highcharts.DataTableCellType} cellValue\n     * Cell value to search for. `NaN` and `undefined` are not supported.\n     *\n     * @param {number} [rowIndexOffset]\n     * Index offset to start searching.\n     *\n     * @return {number|undefined}\n     * Index of the first row matching the cell value.\n     */\n    getRowIndexBy(columnName, cellValue, rowIndexOffset) {\n        const table = this;\n        const column = table.columns[columnName];\n        if (column) {\n            let rowIndex = -1;\n            if (Array.isArray(column)) {\n                // Normal array\n                rowIndex = column.indexOf(cellValue, rowIndexOffset);\n            }\n            else if (isNumber(cellValue)) {\n                // Typed array\n                rowIndex = column.indexOf(cellValue, rowIndexOffset);\n            }\n            if (rowIndex !== -1) {\n                return rowIndex;\n            }\n        }\n    }\n    /**\n     * Retrieves the row at a given index. This function is a simplified wrap of\n     * {@link getRowObjects}.\n     *\n     * @function Highcharts.DataTable#getRowObject\n     *\n     * @param {number} rowIndex\n     * Row index.\n     *\n     * @param {Array<string>} [columnNames]\n     * Column names and their order to retrieve.\n     *\n     * @return {Highcharts.DataTableRowObject}\n     * Returns the row values, or `undefined` if not found.\n     */\n    getRowObject(rowIndex, columnNames) {\n        return this.getRowObjects(rowIndex, 1, columnNames)[0];\n    }\n    /**\n     * Fetches all or a number of rows.\n     *\n     * @function Highcharts.DataTable#getRowObjects\n     *\n     * @param {number} [rowIndex]\n     * Index of the first row to fetch. Defaults to first row at index `0`.\n     *\n     * @param {number} [rowCount]\n     * Number of rows to fetch. Defaults to maximal number of rows.\n     *\n     * @param {Array<string>} [columnNames]\n     * Column names and their order to retrieve.\n     *\n     * @return {Highcharts.DataTableRowObject}\n     * Returns retrieved rows.\n     */\n    getRowObjects(rowIndex = 0, rowCount = (this.rowCount - rowIndex), columnNames) {\n        const table = this, columns = table.columns, rows = new Array(rowCount);\n        columnNames = (columnNames || Object.keys(columns));\n        for (let i = rowIndex, i2 = 0, iEnd = Math.min(table.rowCount, (rowIndex + rowCount)), column, row; i < iEnd; ++i, ++i2) {\n            row = rows[i2] = {};\n            for (const columnName of columnNames) {\n                column = columns[columnName];\n                row[columnName] = (column ? column[i] : void 0);\n            }\n        }\n        return rows;\n    }\n    /**\n     * Fetches all or a number of rows.\n     *\n     * @function Highcharts.DataTable#getRows\n     *\n     * @param {number} [rowIndex]\n     * Index of the first row to fetch. Defaults to first row at index `0`.\n     *\n     * @param {number} [rowCount]\n     * Number of rows to fetch. Defaults to maximal number of rows.\n     *\n     * @param {Array<string>} [columnNames]\n     * Column names and their order to retrieve.\n     *\n     * @return {Highcharts.DataTableRow}\n     * Returns retrieved rows.\n     */\n    getRows(rowIndex = 0, rowCount = (this.rowCount - rowIndex), columnNames) {\n        const table = this, columns = table.columns, rows = new Array(rowCount);\n        columnNames = (columnNames || Object.keys(columns));\n        for (let i = rowIndex, i2 = 0, iEnd = Math.min(table.rowCount, (rowIndex + rowCount)), column, row; i < iEnd; ++i, ++i2) {\n            row = rows[i2] = [];\n            for (const columnName of columnNames) {\n                column = columns[columnName];\n                row.push(column ? column[i] : void 0);\n            }\n        }\n        return rows;\n    }\n    /**\n     * Returns the unique version tag of the current state of the table.\n     *\n     * @function Highcharts.DataTable#getVersionTag\n     *\n     * @return {string}\n     * Unique version tag.\n     */\n    getVersionTag() {\n        return this.versionTag;\n    }\n    /**\n     * Checks for given column names.\n     *\n     * @function Highcharts.DataTable#hasColumns\n     *\n     * @param {Array<string>} columnNames\n     * Column names to check.\n     *\n     * @return {boolean}\n     * Returns `true` if all columns have been found, otherwise `false`.\n     */\n    hasColumns(columnNames) {\n        const table = this, columns = table.columns;\n        for (let i = 0, iEnd = columnNames.length, columnName; i < iEnd; ++i) {\n            columnName = columnNames[i];\n            if (!columns[columnName]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Searches for a specific cell value.\n     *\n     * @function Highcharts.DataTable#hasRowWith\n     *\n     * @param {string} columnName\n     * Column to search in.\n     *\n     * @param {Highcharts.DataTableCellType} cellValue\n     * Cell value to search for. `NaN` and `undefined` are not supported.\n     *\n     * @return {boolean}\n     * True, if a row has been found, otherwise false.\n     */\n    hasRowWith(columnName, cellValue) {\n        const table = this;\n        const column = table.columns[columnName];\n        // Normal array\n        if (Array.isArray(column)) {\n            return (column.indexOf(cellValue) !== -1);\n        }\n        // Typed array\n        if (defined(cellValue) && Number.isFinite(cellValue)) {\n            return (column.indexOf(+cellValue) !== -1);\n        }\n        return false;\n    }\n    /**\n     * Registers a callback for a specific event.\n     *\n     * @function Highcharts.DataTable#on\n     *\n     * @param {string} type\n     * Event type as a string.\n     *\n     * @param {Highcharts.EventCallbackFunction<Highcharts.DataTable>} callback\n     * Function to register for an event callback.\n     *\n     * @return {Function}\n     * Function to unregister callback from the event.\n     */\n    on(type, callback) {\n        return DataTable_addEvent(this, type, callback);\n    }\n    /**\n     * Renames a column of cell values.\n     *\n     * @function Highcharts.DataTable#renameColumn\n     *\n     * @param {string} columnName\n     * Name of the column to be renamed.\n     *\n     * @param {string} newColumnName\n     * New name of the column. An existing column with the same name will be\n     * replaced.\n     *\n     * @return {boolean}\n     * Returns `true` if successful, `false` if the column was not found.\n     */\n    renameColumn(columnName, newColumnName) {\n        const table = this, columns = table.columns;\n        if (columns[columnName]) {\n            if (columnName !== newColumnName) {\n                columns[newColumnName] = columns[columnName];\n                delete columns[columnName];\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Sets a cell value based on the row index and column.  Will\n     * insert a new column, if not found.\n     *\n     * @function Highcharts.DataTable#setCell\n     *\n     * @param {string} columnName\n     * Column name to set.\n     *\n     * @param {number|undefined} rowIndex\n     * Row index to set.\n     *\n     * @param {Highcharts.DataTableCellType} cellValue\n     * Cell value to set.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #setCell\n     * @emits #afterSetCell\n     */\n    setCell(columnName, rowIndex, cellValue, eventDetail) {\n        const table = this, columns = table.columns, modifier = table.modifier;\n        let column = columns[columnName];\n        if (column && column[rowIndex] === cellValue) {\n            return;\n        }\n        table.emit({\n            type: 'setCell',\n            cellValue,\n            columnName: columnName,\n            detail: eventDetail,\n            rowIndex\n        });\n        if (!column) {\n            column = columns[columnName] = new Array(table.rowCount);\n        }\n        if (rowIndex >= table.rowCount) {\n            table.rowCount = (rowIndex + 1);\n        }\n        column[rowIndex] = cellValue;\n        if (modifier) {\n            modifier.modifyCell(table, columnName, rowIndex, cellValue);\n        }\n        table.emit({\n            type: 'afterSetCell',\n            cellValue,\n            columnName: columnName,\n            detail: eventDetail,\n            rowIndex\n        });\n    }\n    /**\n     * Sets cell values for multiple columns. Will insert new columns, if not\n     * found.\n     *\n     * @function Highcharts.DataTable#setColumns\n     *\n     * @param {Highcharts.DataTableColumnCollection} columns\n     * Columns as a collection, where the keys are the column names.\n     *\n     * @param {number} [rowIndex]\n     * Index of the first row to change. Keep undefined to reset.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @param {boolean} [typeAsOriginal=false]\n     * Determines whether the original column retains its type when data\n     * replaced. If `true`, the original column keeps its type. If not\n     * (default), the original column will adopt the type of the replacement\n     * column.\n     *\n     * @emits #setColumns\n     * @emits #afterSetColumns\n     */\n    setColumns(columns, rowIndex, eventDetail, typeAsOriginal) {\n        const table = this, tableColumns = table.columns, tableModifier = table.modifier, columnNames = Object.keys(columns);\n        let rowCount = table.rowCount;\n        table.emit({\n            type: 'setColumns',\n            columns,\n            columnNames,\n            detail: eventDetail,\n            rowIndex\n        });\n        if (!defined(rowIndex) && !typeAsOriginal) {\n            super.setColumns(columns, rowIndex, extend(eventDetail, { silent: true }));\n        }\n        else {\n            for (let i = 0, iEnd = columnNames.length, column, tableColumn, columnName, ArrayConstructor; i < iEnd; ++i) {\n                columnName = columnNames[i];\n                column = columns[columnName];\n                tableColumn = tableColumns[columnName];\n                ArrayConstructor = Object.getPrototypeOf((tableColumn && typeAsOriginal) ? tableColumn : column).constructor;\n                if (!tableColumn) {\n                    tableColumn = new ArrayConstructor(rowCount);\n                }\n                else if (ArrayConstructor === Array) {\n                    if (!Array.isArray(tableColumn)) {\n                        tableColumn = Array.from(tableColumn);\n                    }\n                }\n                else if (tableColumn.length < rowCount) {\n                    tableColumn =\n                        new ArrayConstructor(rowCount);\n                    tableColumn.set(tableColumns[columnName]);\n                }\n                tableColumns[columnName] = tableColumn;\n                for (let i = (rowIndex || 0), iEnd = column.length; i < iEnd; ++i) {\n                    tableColumn[i] = column[i];\n                }\n                rowCount = Math.max(rowCount, column.length);\n            }\n            this.applyRowCount(rowCount);\n        }\n        if (tableModifier) {\n            tableModifier.modifyColumns(table, columns, rowIndex || 0);\n        }\n        table.emit({\n            type: 'afterSetColumns',\n            columns,\n            columnNames,\n            detail: eventDetail,\n            rowIndex\n        });\n    }\n    /**\n     * Sets or unsets the modifier for the table.\n     *\n     * @param {Highcharts.DataModifier} [modifier]\n     * Modifier to set, or `undefined` to unset.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Promise<Highcharts.DataTable>}\n     * Resolves to this table if successful, or rejects on failure.\n     *\n     * @emits #setModifier\n     * @emits #afterSetModifier\n     */\n    setModifier(modifier, eventDetail) {\n        const table = this;\n        let promise;\n        table.emit({\n            type: 'setModifier',\n            detail: eventDetail,\n            modifier,\n            modified: table.modified\n        });\n        table.modified = table;\n        table.modifier = modifier;\n        if (modifier) {\n            promise = modifier.modify(table);\n        }\n        else {\n            promise = Promise.resolve(table);\n        }\n        return promise\n            .then((table) => {\n            table.emit({\n                type: 'afterSetModifier',\n                detail: eventDetail,\n                modifier,\n                modified: table.modified\n            });\n            return table;\n        })['catch']((error) => {\n            table.emit({\n                type: 'setModifierError',\n                error,\n                modifier,\n                modified: table.modified\n            });\n            throw error;\n        });\n    }\n    /**\n     * Sets the original row indexes for the table. It is used to keep the\n     * reference to the original rows when modifying the table.\n     *\n     * @param {Array<number|undefined>} originalRowIndexes\n     * Original row indexes array.\n     *\n     * @param {boolean} omitLocalRowIndexes\n     * Whether to omit the local row indexes calculation. Defaults to `false`.\n     */\n    setOriginalRowIndexes(originalRowIndexes, omitLocalRowIndexes = false) {\n        this.originalRowIndexes = originalRowIndexes;\n        if (omitLocalRowIndexes) {\n            return;\n        }\n        const modifiedIndexes = this.localRowIndexes = [];\n        for (let i = 0, iEnd = originalRowIndexes.length, originalIndex; i < iEnd; ++i) {\n            originalIndex = originalRowIndexes[i];\n            if (defined(originalIndex)) {\n                modifiedIndexes[originalIndex] = i;\n            }\n        }\n    }\n    /**\n     * Sets cell values of a row. Will insert a new row, if no index was\n     * provided, or if the index is higher than the total number of table rows.\n     *\n     * Note: This function is just a simplified wrap of\n     * {@link Highcharts.DataTable#setRows}.\n     *\n     * @function Highcharts.DataTable#setRow\n     *\n     * @param {Highcharts.DataTableRow|Highcharts.DataTableRowObject} row\n     * Cell values to set.\n     *\n     * @param {number} [rowIndex]\n     * Index of the row to set. Leave `undefind` to add as a new row.\n     *\n     * @param {boolean} [insert]\n     * Whether to insert the row at the given index, or to overwrite the row.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #setRows\n     * @emits #afterSetRows\n     */\n    setRow(row, rowIndex, insert, eventDetail) {\n        this.setRows([row], rowIndex, insert, eventDetail);\n    }\n    /**\n     * Sets cell values for multiple rows. Will insert new rows, if no index was\n     * was provided, or if the index is higher than the total number of table\n     * rows.\n     *\n     * @function Highcharts.DataTable#setRows\n     *\n     * @param {Array<(Highcharts.DataTableRow|Highcharts.DataTableRowObject)>} rows\n     * Row values to set.\n     *\n     * @param {number} [rowIndex]\n     * Index of the first row to set. Leave `undefined` to add as new rows.\n     *\n     * @param {boolean} [insert]\n     * Whether to insert the row at the given index, or to overwrite the row.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #setRows\n     * @emits #afterSetRows\n     */\n    setRows(rows, rowIndex = this.rowCount, insert, eventDetail) {\n        const table = this, columns = table.columns, columnNames = Object.keys(columns), modifier = table.modifier, rowCount = rows.length;\n        table.emit({\n            type: 'setRows',\n            detail: eventDetail,\n            rowCount,\n            rowIndex,\n            rows\n        });\n        for (let i = 0, i2 = rowIndex, row; i < rowCount; ++i, ++i2) {\n            row = rows[i];\n            if (row === DataTable.NULL) {\n                for (let j = 0, jEnd = columnNames.length; j < jEnd; ++j) {\n                    const column = columns[columnNames[j]];\n                    if (insert) {\n                        columns[columnNames[j]] = Data_ColumnUtils.splice(column, i2, 0, true, [null]).array;\n                    }\n                    else {\n                        column[i2] = null;\n                    }\n                }\n            }\n            else if (row instanceof Array) {\n                for (let j = 0, jEnd = columnNames.length; j < jEnd; ++j) {\n                    columns[columnNames[j]][i2] = row[j];\n                }\n            }\n            else {\n                super.setRow(row, i2, void 0, { silent: true });\n            }\n        }\n        const indexRowCount = insert ?\n            rowCount + rows.length :\n            rowIndex + rowCount;\n        if (indexRowCount > table.rowCount) {\n            table.rowCount = indexRowCount;\n            for (let i = 0, iEnd = columnNames.length; i < iEnd; ++i) {\n                const columnName = columnNames[i];\n                columns[columnName] = Data_ColumnUtils.setLength(columns[columnName], indexRowCount);\n            }\n        }\n        if (modifier) {\n            modifier.modifyRows(table, rows, rowIndex);\n        }\n        table.emit({\n            type: 'afterSetRows',\n            detail: eventDetail,\n            rowCount,\n            rowIndex,\n            rows\n        });\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Null state for a row record. In some cases, a row in a table may not\n * contain any data or may be invalid. In these cases, a null state can be\n * used to indicate that the row record is empty or invalid.\n *\n * @name Highcharts.DataTable.NULL\n * @type {Highcharts.DataTableRowObject}\n *\n * @see {@link Highcharts.DataTable.isNull} for a null test.\n *\n * @example\n * table.setRows([DataTable.NULL, DataTable.NULL], 10);\n */\nDataTable.NULL = {};\n/**\n * Semantic version string of the DataTable class.\n * @internal\n */\nDataTable.version = '1.0.0';\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Data_DataTable = (DataTable);\n\n;// ./code/es-modules/Data/Connectors/DataConnector.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *  - Wojciech Chmiel\n *  - GÃ¸ran Slettemark\n *\n * */\n\n\n\n\nconst { addEvent: DataConnector_addEvent, fireEvent: DataConnector_fireEvent, merge: DataConnector_merge, pick } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Abstract class providing an interface for managing a DataConnector.\n *\n * @private\n */\nclass DataConnector {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructor for the connector class.\n     *\n     * @param {DataConnector.UserOptions} [options]\n     * Options to use in the connector.\n     *\n     * @param {Array<DataTableOptions>} [dataTables]\n     * Multiple connector data tables options.\n     */\n    constructor(options = {}, dataTables = []) {\n        /**\n         * Tables managed by this DataConnector instance.\n         */\n        this.dataTables = {};\n        /**\n         * Helper flag for detecting whether the data connector is loaded.\n         * @internal\n         */\n        this.loaded = false;\n        this.metadata = options.metadata || { columns: {} };\n        // Create a data table for each defined in the dataTables user options.\n        let dataTableIndex = 0;\n        if (dataTables?.length > 0) {\n            for (let i = 0, iEnd = dataTables.length; i < iEnd; ++i) {\n                const dataTable = dataTables[i];\n                const key = dataTable?.key;\n                this.dataTables[key ?? dataTableIndex] =\n                    new Data_DataTable(dataTable);\n                if (!key) {\n                    dataTableIndex++;\n                }\n            }\n            // If user options dataTables is not defined, generate a default table.\n        }\n        else {\n            this.dataTables[0] = new Data_DataTable(options.dataTable);\n        }\n    }\n    /**\n     * Poll timer ID, if active.\n     */\n    get polling() {\n        return !!this._polling;\n    }\n    /**\n     * Gets the first data table.\n     *\n     * @return {DataTable}\n     * The data table instance.\n     */\n    get table() {\n        return this.getTable();\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Method for adding metadata for a single column.\n     *\n     * @param {string} name\n     * The name of the column to be described.\n     *\n     * @param {DataConnector.MetaColumn} columnMeta\n     * The metadata to apply to the column.\n     */\n    describeColumn(name, columnMeta) {\n        const connector = this, columns = connector.metadata.columns;\n        columns[name] = DataConnector_merge(columns[name] || {}, columnMeta);\n    }\n    /**\n     * Method for applying columns meta information to the whole DataConnector.\n     *\n     * @param {Highcharts.Dictionary<DataConnector.MetaColumn>} columns\n     * Pairs of column names and MetaColumn objects.\n     */\n    describeColumns(columns) {\n        const connector = this, columnNames = Object.keys(columns);\n        let columnName;\n        while (typeof (columnName = columnNames.pop()) === 'string') {\n            connector.describeColumn(columnName, columns[columnName]);\n        }\n    }\n    /**\n     * Emits an event on the connector to all registered callbacks of this\n     * event.\n     *\n     * @param {DataConnector.Event} [e]\n     * Event object containing additional event information.\n     */\n    emit(e) {\n        DataConnector_fireEvent(this, e.type, e);\n    }\n    /**\n     * Returns the order of columns.\n     *\n     * @param {boolean} [usePresentationState]\n     * Whether to use the column order of the presentation state of the table.\n     *\n     * @return {Array<string>|undefined}\n     * Order of columns.\n     */\n    getColumnOrder(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    usePresentationState) {\n        const connector = this, columns = connector.metadata.columns, names = Object.keys(columns || {});\n        if (names.length) {\n            return names.sort((a, b) => (pick(columns[a].index, 0) - pick(columns[b].index, 0)));\n        }\n    }\n    /**\n     * Returns a single data table instance based on the provided key.\n     * Otherwise, returns the first data table.\n     *\n     * @param {string} [key]\n     * The data table key.\n     *\n     * @return {DataTable}\n     * The data table instance.\n     */\n    getTable(key) {\n        if (key) {\n            return this.dataTables[key];\n        }\n        return Object.values(this.dataTables)[0];\n    }\n    /**\n     * Retrieves the columns of the dataTable,\n     * applies column order from meta.\n     *\n     * @param {boolean} [usePresentationOrder]\n     * Whether to use the column order of the presentation state of the table.\n     *\n     * @return {Highcharts.DataTableColumnCollection}\n     * An object with the properties `columnNames` and `columnValues`\n     */\n    getSortedColumns(usePresentationOrder) {\n        return this.table.getColumns(this.getColumnOrder(usePresentationOrder));\n    }\n    /**\n     * The default load method, which fires the `afterLoad` event\n     *\n     * @return {Promise<DataConnector>}\n     * The loaded connector.\n     *\n     * @emits DataConnector#afterLoad\n     */\n    load() {\n        DataConnector_fireEvent(this, 'afterLoad', { table: this.table });\n        return Promise.resolve(this);\n    }\n    /**\n     * Registers a callback for a specific connector event.\n     *\n     * @param {string} type\n     * Event type as a string.\n     *\n     * @param {DataEventEmitter.Callback} callback\n     * Function to register for the connector callback.\n     *\n     * @return {Function}\n     * Function to unregister callback from the connector event.\n     */\n    on(type, callback) {\n        return DataConnector_addEvent(this, type, callback);\n    }\n    /**\n     * The default save method, which fires the `afterSave` event.\n     *\n     * @return {Promise<DataConnector>}\n     * The saved connector.\n     *\n     * @emits DataConnector#afterSave\n     * @emits DataConnector#saveError\n     */\n    save() {\n        DataConnector_fireEvent(this, 'saveError', { table: this.table });\n        return Promise.reject(new Error('Not implemented'));\n    }\n    /**\n     * Sets the index and order of columns.\n     *\n     * @param {Array<string>} columnNames\n     * Order of columns.\n     */\n    setColumnOrder(columnNames) {\n        const connector = this;\n        for (let i = 0, iEnd = columnNames.length; i < iEnd; ++i) {\n            connector.describeColumn(columnNames[i], { index: i });\n        }\n    }\n    async setModifierOptions(modifierOptions, tablesOptions) {\n        for (const [key, table] of Object.entries(this.dataTables)) {\n            const tableOptions = tablesOptions?.find((dataTable) => dataTable.key === key);\n            const mergedModifierOptions = DataConnector_merge(tableOptions?.dataModifier, modifierOptions);\n            const ModifierClass = (mergedModifierOptions &&\n                Modifiers_DataModifier.types[mergedModifierOptions.type]);\n            await table.setModifier(ModifierClass ?\n                new ModifierClass(mergedModifierOptions) :\n                void 0);\n        }\n        return this;\n    }\n    /**\n     * Starts polling new data after the specific time span in milliseconds.\n     *\n     * @param {number} refreshTime\n     * Refresh time in milliseconds between polls.\n     */\n    startPolling(refreshTime = 1000) {\n        const connector = this;\n        const tables = connector.dataTables;\n        // Assign a new abort controller.\n        this.pollingController = new AbortController();\n        // Clear the polling timeout.\n        window.clearTimeout(connector._polling);\n        connector._polling = window.setTimeout(() => connector\n            .load()['catch']((error) => connector.emit({\n            type: 'loadError',\n            error,\n            tables\n        }))\n            .then(() => {\n            if (connector._polling) {\n                connector.startPolling(refreshTime);\n            }\n        }), refreshTime);\n    }\n    /**\n     * Stops polling data. Shouldn't be performed if polling is already stopped.\n     */\n    stopPolling() {\n        const connector = this;\n        if (!connector.polling) {\n            return;\n        }\n        // Abort the existing request.\n        connector?.pollingController?.abort();\n        // Clear the polling timeout.\n        window.clearTimeout(connector._polling);\n        delete connector._polling;\n    }\n    /**\n     * Retrieves metadata from a single column.\n     *\n     * @param {string} name\n     * The identifier for the column that should be described\n     *\n     * @return {DataConnector.MetaColumn|undefined}\n     * Returns a MetaColumn object if found.\n     */\n    whatIs(name) {\n        return this.metadata.columns[name];\n    }\n    /**\n     * Iterates over the dataTables and initiates the corresponding converters.\n     * Updates the dataTables and assigns the first converter.\n     *\n     * @param {T}[data]\n     * Data specific to the corresponding converter.\n     *\n     * @param {DataConnector.CreateConverterFunction}[createConverter]\n     * Creates a specific converter combining the dataTable options.\n     *\n     * @param {DataConnector.ParseDataFunction<T>}[parseData]\n     * Runs the converter parse method with the specific data type.\n     */\n    initConverters(data, createConverter, parseData) {\n        let index = 0;\n        for (const [key, table] of Object.entries(this.dataTables)) {\n            // Create a proper converter and parse its data.\n            const converter = createConverter(key, table);\n            parseData(converter, data);\n            // Update the dataTable.\n            table.deleteColumns();\n            table.setColumns(converter.getTable().getColumns());\n            // Assign the first converter.\n            if (index === 0) {\n                this.converter = converter;\n            }\n            index++;\n        }\n    }\n}\n/* *\n *\n *  Class Namespace\n *\n * */\n(function (DataConnector) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Constants\n     *\n     * */\n    /**\n     * Registry as a record object with connector names and their class.\n     */\n    DataConnector.types = {};\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Adds a connector class to the registry. The connector has to provide the\n     * `DataConnector.options` property and the `DataConnector.load` method to\n     * modify the table.\n     *\n     * @private\n     *\n     * @param {string} key\n     * Registry key of the connector class.\n     *\n     * @param {DataConnectorType} DataConnectorClass\n     * Connector class (aka class constructor) to register.\n     *\n     * @return {boolean}\n     * Returns true, if the registration was successful. False is returned, if\n     * their is already a connector registered with this key.\n     */\n    function registerType(key, DataConnectorClass) {\n        return (!!key &&\n            !DataConnector.types[key] &&\n            !!(DataConnector.types[key] = DataConnectorClass));\n    }\n    DataConnector.registerType = registerType;\n})(DataConnector || (DataConnector = {}));\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Connectors_DataConnector = (DataConnector);\n\n;// ./code/es-modules/Data/Converters/DataConverter.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *  - Sebastian Bochan\n *  - GÃ¸ran Slettemark\n *  - Torstein HÃ¸nsi\n *  - Wojciech Chmiel\n *  - Jomar HÃ¸nsi\n *\n * */\n\n\n\nconst { addEvent: DataConverter_addEvent, fireEvent: DataConverter_fireEvent, isNumber: DataConverter_isNumber, merge: DataConverter_merge } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Base class providing an interface and basic methods for a DataConverter\n *\n * @private\n */\nclass DataConverter {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of the DataConverter.\n     *\n     * @param {DataConverter.UserOptions} [options]\n     * Options for the DataConverter.\n     */\n    constructor(options) {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        /**\n         * A collection of available date formats.\n         */\n        this.dateFormats = {\n            'YYYY/mm/dd': {\n                regex: /^(\\d{4})([\\-\\.\\/])(\\d{1,2})\\2(\\d{1,2})$/,\n                parser: function (match) {\n                    return (match ?\n                        Date.UTC(+match[1], match[3] - 1, +match[4]) :\n                        NaN);\n                }\n            },\n            'dd/mm/YYYY': {\n                regex: /^(\\d{1,2})([\\-\\.\\/])(\\d{1,2})\\2(\\d{4})$/,\n                parser: function (match) {\n                    return (match ?\n                        Date.UTC(+match[4], match[3] - 1, +match[1]) :\n                        NaN);\n                },\n                alternative: 'mm/dd/YYYY' // Different format with the same regex\n            },\n            'mm/dd/YYYY': {\n                regex: /^(\\d{1,2})([\\-\\.\\/])(\\d{1,2})\\2(\\d{4})$/,\n                parser: function (match) {\n                    return (match ?\n                        Date.UTC(+match[4], match[1] - 1, +match[3]) :\n                        NaN);\n                }\n            },\n            'dd/mm/YY': {\n                regex: /^(\\d{1,2})([\\-\\.\\/])(\\d{1,2})\\2(\\d{2})$/,\n                parser: function (match) {\n                    const d = new Date();\n                    if (!match) {\n                        return NaN;\n                    }\n                    let year = +match[4];\n                    if (year > (d.getFullYear() - 2000)) {\n                        year += 1900;\n                    }\n                    else {\n                        year += 2000;\n                    }\n                    return Date.UTC(year, match[3] - 1, +match[1]);\n                },\n                alternative: 'mm/dd/YY' // Different format with the same regex\n            },\n            'mm/dd/YY': {\n                regex: /^(\\d{1,2})([\\-\\.\\/])(\\d{1,2})\\2(\\d{2})$/,\n                parser: function (match) {\n                    return (match ?\n                        Date.UTC(+match[4] + 2000, match[1] - 1, +match[3]) :\n                        NaN);\n                }\n            }\n        };\n        const mergedOptions = DataConverter_merge(DataConverter.defaultOptions, options);\n        let regExpPoint = mergedOptions.decimalPoint;\n        if (regExpPoint === '.' || regExpPoint === ',') {\n            regExpPoint = regExpPoint === '.' ? '\\\\.' : ',';\n            this.decimalRegExp =\n                new RegExp('^(-?[0-9]+)' + regExpPoint + '([0-9]+)$');\n        }\n        this.options = mergedOptions;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Converts a value to a boolean.\n     *\n     * @param {DataConverter.Type} value\n     * Value to convert.\n     *\n     * @return {boolean}\n     * Converted value as a boolean.\n     */\n    asBoolean(value) {\n        if (typeof value === 'boolean') {\n            return value;\n        }\n        if (typeof value === 'string') {\n            return value !== '' && value !== '0' && value !== 'false';\n        }\n        return !!this.asNumber(value);\n    }\n    /**\n     * Converts a value to a Date.\n     *\n     * @param {DataConverter.Type} value\n     * Value to convert.\n     *\n     * @return {globalThis.Date}\n     * Converted value as a Date.\n     */\n    asDate(value) {\n        let timestamp;\n        if (typeof value === 'string') {\n            timestamp = this.parseDate(value);\n        }\n        else if (typeof value === 'number') {\n            timestamp = value;\n        }\n        else if (value instanceof Date) {\n            return value;\n        }\n        else {\n            timestamp = this.parseDate(this.asString(value));\n        }\n        return new Date(timestamp);\n    }\n    /**\n     * Casts a string value to it's guessed type\n     *\n     * @param {*} value\n     * The value to examine.\n     *\n     * @return {number|string|Date}\n     * The converted value.\n     */\n    asGuessedType(value) {\n        const converter = this, typeMap = {\n            'number': converter.asNumber,\n            'Date': converter.asDate,\n            'string': converter.asString\n        };\n        return typeMap[converter.guessType(value)].call(converter, value);\n    }\n    /**\n     * Converts a value to a number.\n     *\n     * @param {DataConverter.Type} value\n     * Value to convert.\n     *\n     * @return {number}\n     * Converted value as a number.\n     */\n    asNumber(value) {\n        if (typeof value === 'number') {\n            return value;\n        }\n        if (typeof value === 'boolean') {\n            return value ? 1 : 0;\n        }\n        if (typeof value === 'string') {\n            const decimalRegex = this.decimalRegExp;\n            if (value.indexOf(' ') > -1) {\n                value = value.replace(/\\s+/g, '');\n            }\n            if (decimalRegex) {\n                if (!decimalRegex.test(value)) {\n                    return NaN;\n                }\n                value = value.replace(decimalRegex, '$1.$2');\n            }\n            return parseFloat(value);\n        }\n        if (value instanceof Date) {\n            return value.getDate();\n        }\n        if (value) {\n            return value.getRowCount();\n        }\n        return NaN;\n    }\n    /**\n     * Converts a value to a string.\n     *\n     * @param {DataConverter.Type} value\n     * Value to convert.\n     *\n     * @return {string}\n     * Converted value as a string.\n     */\n    asString(value) {\n        return '' + value;\n    }\n    /**\n     * Tries to guess the date format\n     *  - Check if either month candidate exceeds 12\n     *  - Check if year is missing (use current year)\n     *  - Check if a shortened year format is used (e.g. 1/1/99)\n     *  - If no guess can be made, the user must be prompted\n     * data is the data to deduce a format based on\n     * @private\n     *\n     * @param {Array<string>} data\n     * Data to check the format.\n     *\n     * @param {number} limit\n     * Max data to check the format.\n     *\n     * @param {boolean} save\n     * Whether to save the date format in the converter options.\n     */\n    deduceDateFormat(data, limit, save) {\n        const parser = this, stable = [], max = [];\n        let format = 'YYYY/mm/dd', thing, guessedFormat = [], i = 0, madeDeduction = false, \n        /// candidates = {},\n        elem, j;\n        if (!limit || limit > data.length) {\n            limit = data.length;\n        }\n        for (; i < limit; i++) {\n            if (typeof data[i] !== 'undefined' &&\n                data[i] && data[i].length) {\n                thing = data[i]\n                    .trim()\n                    .replace(/[\\-\\.\\/]/g, ' ')\n                    .split(' ');\n                guessedFormat = [\n                    '',\n                    '',\n                    ''\n                ];\n                for (j = 0; j < thing.length; j++) {\n                    if (j < guessedFormat.length) {\n                        elem = parseInt(thing[j], 10);\n                        if (elem) {\n                            max[j] = (!max[j] || max[j] < elem) ? elem : max[j];\n                            if (typeof stable[j] !== 'undefined') {\n                                if (stable[j] !== elem) {\n                                    stable[j] = false;\n                                }\n                            }\n                            else {\n                                stable[j] = elem;\n                            }\n                            if (elem > 31) {\n                                if (elem < 100) {\n                                    guessedFormat[j] = 'YY';\n                                }\n                                else {\n                                    guessedFormat[j] = 'YYYY';\n                                }\n                                /// madeDeduction = true;\n                            }\n                            else if (elem > 12 &&\n                                elem <= 31) {\n                                guessedFormat[j] = 'dd';\n                                madeDeduction = true;\n                            }\n                            else if (!guessedFormat[j].length) {\n                                guessedFormat[j] = 'mm';\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (madeDeduction) {\n            // This handles a few edge cases with hard to guess dates\n            for (j = 0; j < stable.length; j++) {\n                if (stable[j] !== false) {\n                    if (max[j] > 12 &&\n                        guessedFormat[j] !== 'YY' &&\n                        guessedFormat[j] !== 'YYYY') {\n                        guessedFormat[j] = 'YY';\n                    }\n                }\n                else if (max[j] > 12 && guessedFormat[j] === 'mm') {\n                    guessedFormat[j] = 'dd';\n                }\n            }\n            // If the middle one is dd, and the last one is dd,\n            // the last should likely be year.\n            if (guessedFormat.length === 3 &&\n                guessedFormat[1] === 'dd' &&\n                guessedFormat[2] === 'dd') {\n                guessedFormat[2] = 'YY';\n            }\n            format = guessedFormat.join('/');\n            // If the caculated format is not valid, we need to present an\n            // error.\n        }\n        // Save the deduced format in the converter options.\n        if (save) {\n            parser.options.dateFormat = format;\n        }\n        return format;\n    }\n    /**\n     * Emits an event on the DataConverter instance.\n     *\n     * @param {DataConverter.Event} [e]\n     * Event object containing additional event data\n     */\n    emit(e) {\n        DataConverter_fireEvent(this, e.type, e);\n    }\n    /**\n     * Initiates the data exporting. Should emit `exportError` on failure.\n     *\n     * @param {DataConnector} connector\n     * Connector to export from.\n     *\n     * @param {DataConverter.Options} [options]\n     * Options for the export.\n     */\n    export(\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    connector, options\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n    ) {\n        this.emit({\n            type: 'exportError',\n            columns: [],\n            headers: []\n        });\n        throw new Error('Not implemented');\n    }\n    /**\n     * Getter for the data table.\n     *\n     * @return {DataTable}\n     * Table of parsed data.\n     */\n    getTable() {\n        throw new Error('Not implemented');\n    }\n    /**\n     * Guesses the potential type of a string value for parsing CSV etc.\n     *\n     * @param {*} value\n     * The value to examine.\n     *\n     * @return {'number'|'string'|'Date'}\n     * Type string, either `string`, `Date`, or `number`.\n     */\n    guessType(value) {\n        const converter = this;\n        let result = 'string';\n        if (typeof value === 'string') {\n            const trimedValue = converter.trim(`${value}`), decimalRegExp = converter.decimalRegExp;\n            let innerTrimedValue = converter.trim(trimedValue, true);\n            if (decimalRegExp) {\n                innerTrimedValue = (decimalRegExp.test(innerTrimedValue) ?\n                    innerTrimedValue.replace(decimalRegExp, '$1.$2') :\n                    '');\n            }\n            const floatValue = parseFloat(innerTrimedValue);\n            if (+innerTrimedValue === floatValue) {\n                // String is numeric\n                value = floatValue;\n            }\n            else {\n                // Determine if a date string\n                const dateValue = converter.parseDate(value);\n                result = DataConverter_isNumber(dateValue) ? 'Date' : 'string';\n            }\n        }\n        if (typeof value === 'number') {\n            // Greater than milliseconds in a year assumed timestamp\n            result = value > 365 * 24 * 3600 * 1000 ? 'Date' : 'number';\n        }\n        return result;\n    }\n    /**\n     * Registers a callback for a specific event.\n     *\n     * @param {string} type\n     * Event type as a string.\n     *\n     * @param {DataEventEmitter.Callback} callback\n     * Function to register for an modifier callback.\n     *\n     * @return {Function}\n     * Function to unregister callback from the modifier event.\n     */\n    on(type, callback) {\n        return DataConverter_addEvent(this, type, callback);\n    }\n    /**\n     * Initiates the data parsing. Should emit `parseError` on failure.\n     *\n     * @param {DataConverter.UserOptions} options\n     * Options of the DataConverter.\n     */\n    parse(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        this.emit({\n            type: 'parseError',\n            columns: [],\n            headers: []\n        });\n        throw new Error('Not implemented');\n    }\n    /**\n     * Parse a date and return it as a number.\n     *\n     * @param {string} value\n     * Value to parse.\n     *\n     * @param {string} dateFormatProp\n     * Which of the predefined date formats\n     * to use to parse date values.\n     */\n    parseDate(value, dateFormatProp) {\n        const converter = this, options = converter.options;\n        let dateFormat = dateFormatProp || options.dateFormat, result = NaN, key, format, match;\n        if (options.parseDate) {\n            result = options.parseDate(value);\n        }\n        else {\n            // Auto-detect the date format the first time\n            if (!dateFormat) {\n                for (key in converter.dateFormats) { // eslint-disable-line guard-for-in\n                    format = converter.dateFormats[key];\n                    match = value.match(format.regex);\n                    if (match) {\n                        // `converter.options.dateFormat` = dateFormat = key;\n                        dateFormat = key;\n                        // `converter.options.alternativeFormat` =\n                        // format.alternative || '';\n                        result = format.parser(match);\n                        break;\n                    }\n                }\n                // Next time, use the one previously found\n            }\n            else {\n                format = converter.dateFormats[dateFormat];\n                if (!format) {\n                    // The selected format is invalid\n                    format = converter.dateFormats['YYYY/mm/dd'];\n                }\n                match = value.match(format.regex);\n                if (match) {\n                    result = format.parser(match);\n                }\n            }\n            // Fall back to Date.parse\n            if (!match) {\n                match = Date.parse(value);\n                // External tools like Date.js and MooTools extend Date object\n                // and returns a date.\n                if (typeof match === 'object' &&\n                    match !== null &&\n                    match.getTime) {\n                    result = (match.getTime() -\n                        match.getTimezoneOffset() *\n                            60000);\n                    // Timestamp\n                }\n                else if (DataConverter_isNumber(match)) {\n                    result = match - (new Date(match)).getTimezoneOffset() * 60000;\n                    if ( // Reset dates without year in Chrome\n                    value.indexOf('2001') === -1 &&\n                        (new Date(result)).getFullYear() === 2001) {\n                        result = NaN;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Trim a string from whitespaces.\n     *\n     * @param {string} str\n     * String to trim.\n     *\n     * @param {boolean} [inside=false]\n     * Remove all spaces between numbers.\n     *\n     * @return {string}\n     * Trimed string\n     */\n    trim(str, inside) {\n        if (typeof str === 'string') {\n            str = str.replace(/^\\s+|\\s+$/g, '');\n            // Clear white space insdie the string, like thousands separators\n            if (inside && /^[\\d\\s]+$/.test(str)) {\n                str = str.replace(/\\s/g, '');\n            }\n        }\n        return str;\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default options\n */\nDataConverter.defaultOptions = {\n    dateFormat: '',\n    alternativeFormat: '',\n    startColumn: 0,\n    endColumn: Number.MAX_VALUE,\n    startRow: 0,\n    endRow: Number.MAX_VALUE,\n    firstRowAsNames: true,\n    switchRowsAndColumns: false\n};\n/* *\n *\n *  Class Namespace\n *\n * */\n/**\n * Additionally provided types for events and conversion.\n */\n(function (DataConverter) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Constants\n     *\n     * */\n    /**\n     * Registry as a record object with connector names and their class.\n     */\n    DataConverter.types = {};\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Adds a converter class to the registry.\n     *\n     * @private\n     *\n     * @param {string} key\n     * Registry key of the converter class.\n     *\n     * @param {DataConverterTypes} DataConverterClass\n     * Connector class (aka class constructor) to register.\n     *\n     * @return {boolean}\n     * Returns true, if the registration was successful. False is returned, if\n     * their is already a converter registered with this key.\n     */\n    function registerType(key, DataConverterClass) {\n        return (!!key &&\n            !DataConverter.types[key] &&\n            !!(DataConverter.types[key] = DataConverterClass));\n    }\n    DataConverter.registerType = registerType;\n    /**\n     * Converts an array of columns to a table instance. Second dimension of the\n     * array are the row cells.\n     *\n     * @param {Array<DataTable.Column>} [columns]\n     * Array to convert.\n     *\n     * @param {Array<string>} [headers]\n     * Column names to use.\n     *\n     * @return {DataTable}\n     * Table instance from the arrays.\n     */\n    function getTableFromColumns(columns = [], headers = []) {\n        const table = new Data_DataTable();\n        for (let i = 0, iEnd = Math.max(headers.length, columns.length); i < iEnd; ++i) {\n            table.setColumn(headers[i] || `${i}`, columns[i]);\n        }\n        return table;\n    }\n    DataConverter.getTableFromColumns = getTableFromColumns;\n})(DataConverter || (DataConverter = {}));\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Converters_DataConverter = (DataConverter);\n\n;// ./code/es-modules/Data/DataCursor.js\n/* *\n *\n *  (c) 2020-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n/* *\n *\n *  Class\n *\n * */\n/**\n * This class manages state cursors pointing on {@link Data.DataTable}. It\n * creates a relation between states of the user interface and the table cells,\n * columns, or rows.\n *\n * @class\n * @name Data.DataCursor\n */\nclass DataCursor {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    constructor(stateMap = {}) {\n        this.emittingRegister = [];\n        this.listenerMap = {};\n        this.stateMap = stateMap;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * This function registers a listener for a specific state and table.\n     *\n     * @example\n     * ```TypeScript\n     * dataCursor.addListener(myTable.id, 'hover', (e: DataCursor.Event) => {\n     *     if (e.cursor.type === 'position') {\n     *         console.log(`Hover over row #${e.cursor.row}.`);\n     *     }\n     * });\n     * ```\n     *\n     * @function #addListener\n     *\n     * @param {Data.DataCursor.TableId} tableId\n     * The ID of the table to listen to.\n     *\n     * @param {Data.DataCursor.State} state\n     * The state on the table to listen to.\n     *\n     * @param {Data.DataCursor.Listener} listener\n     * The listener to register.\n     *\n     * @return {Data.DataCursor}\n     * Returns the DataCursor instance for a call chain.\n     */\n    addListener(tableId, state, listener) {\n        const listenerMap = this.listenerMap[tableId] = (this.listenerMap[tableId] ||\n            {});\n        const listeners = listenerMap[state] = (listenerMap[state] ||\n            []);\n        listeners.push(listener);\n        return this;\n    }\n    /**\n     * @private\n     */\n    buildEmittingTag(e) {\n        return (e.cursor.type === 'position' ?\n            [\n                e.table.id,\n                e.cursor.column,\n                e.cursor.row,\n                e.cursor.state,\n                e.cursor.type\n            ] :\n            [\n                e.table.id,\n                e.cursor.columns,\n                e.cursor.firstRow,\n                e.cursor.lastRow,\n                e.cursor.state,\n                e.cursor.type\n            ]).join('\\0');\n    }\n    /**\n     * This function emits a state cursor related to a table. It will provide\n     * lasting state cursors of the table to listeners.\n     *\n     * @example\n     * ```ts\n     * dataCursor.emit(myTable, {\n     *     type: 'position',\n     *     column: 'city',\n     *     row: 4,\n     *     state: 'hover',\n     * });\n     * ```\n     *\n     * @param {Data.DataTable} table\n     * The related table of the cursor.\n     *\n     * @param {Data.DataCursor.Type} cursor\n     * The state cursor to emit.\n     *\n     * @param {Event} [event]\n     * Optional event information from a related source.\n     *\n     * @param {boolean} [lasting]\n     * Whether this state cursor should be kept until it is cleared with\n     * {@link DataCursor#remitCursor}.\n     *\n     * @return {Data.DataCursor}\n     * Returns the DataCursor instance for a call chain.\n     */\n    emitCursor(table, cursor, event, lasting) {\n        const tableId = table.id, state = cursor.state, listeners = (this.listenerMap[tableId] &&\n            this.listenerMap[tableId][state]);\n        if (listeners) {\n            const stateMap = this.stateMap[tableId] = (this.stateMap[tableId] ?? {});\n            const cursors = stateMap[cursor.state] || [];\n            if (lasting) {\n                if (!cursors.length) {\n                    stateMap[cursor.state] = cursors;\n                }\n                if (DataCursor.getIndex(cursor, cursors) === -1) {\n                    cursors.push(cursor);\n                }\n            }\n            const e = {\n                cursor,\n                cursors,\n                table\n            };\n            if (event) {\n                e.event = event;\n            }\n            const emittingRegister = this.emittingRegister, emittingTag = this.buildEmittingTag(e);\n            if (emittingRegister.indexOf(emittingTag) >= 0) {\n                // Break call stack loops\n                return this;\n            }\n            try {\n                this.emittingRegister.push(emittingTag);\n                for (let i = 0, iEnd = listeners.length; i < iEnd; ++i) {\n                    listeners[i].call(this, e);\n                }\n            }\n            finally {\n                const index = this.emittingRegister.indexOf(emittingTag);\n                if (index >= 0) {\n                    this.emittingRegister.splice(index, 1);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Removes a lasting state cursor.\n     *\n     * @function #remitCursor\n     *\n     * @param {string} tableId\n     * ID of the related cursor table.\n     *\n     * @param {Data.DataCursor.Type} cursor\n     * Copy or reference of the cursor.\n     *\n     * @return {Data.DataCursor}\n     * Returns the DataCursor instance for a call chain.\n     */\n    remitCursor(tableId, cursor) {\n        const cursors = (this.stateMap[tableId] &&\n            this.stateMap[tableId][cursor.state]);\n        if (cursors) {\n            const index = DataCursor.getIndex(cursor, cursors);\n            if (index >= 0) {\n                cursors.splice(index, 1);\n            }\n        }\n        return this;\n    }\n    /**\n     * This function removes a listener.\n     *\n     * @function #addListener\n     *\n     * @param {Data.DataCursor.TableId} tableId\n     * The ID of the table the listener is connected to.\n     *\n     * @param {Data.DataCursor.State} state\n     * The state on the table the listener is listening to.\n     *\n     * @param {Data.DataCursor.Listener} listener\n     * The listener to deregister.\n     *\n     * @return {Data.DataCursor}\n     * Returns the DataCursor instance for a call chain.\n     */\n    removeListener(tableId, state, listener) {\n        const listeners = (this.listenerMap[tableId] &&\n            this.listenerMap[tableId][state]);\n        if (listeners) {\n            const index = listeners.indexOf(listener);\n            if (index >= 0) {\n                listeners.splice(index, 1);\n            }\n        }\n        return this;\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Semantic version string of the DataCursor class.\n * @internal\n */\nDataCursor.version = '1.0.0';\n/* *\n *\n *  Class Namespace\n *\n * */\n/**\n * @class Data.DataCursor\n */\n(function (DataCursor) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Finds the index of an cursor in an array.\n     * @private\n     */\n    function getIndex(needle, cursors) {\n        if (needle.type === 'position') {\n            for (let cursor, i = 0, iEnd = cursors.length; i < iEnd; ++i) {\n                cursor = cursors[i];\n                if (cursor.type === 'position' &&\n                    cursor.state === needle.state &&\n                    cursor.column === needle.column &&\n                    cursor.row === needle.row) {\n                    return i;\n                }\n            }\n        }\n        else {\n            const columnNeedle = JSON.stringify(needle.columns);\n            for (let cursor, i = 0, iEnd = cursors.length; i < iEnd; ++i) {\n                cursor = cursors[i];\n                if (cursor.type === 'range' &&\n                    cursor.state === needle.state &&\n                    cursor.firstRow === needle.firstRow &&\n                    cursor.lastRow === needle.lastRow &&\n                    JSON.stringify(cursor.columns) === columnNeedle) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    DataCursor.getIndex = getIndex;\n    /**\n     * Checks whether two cursor share the same properties.\n     * @private\n     */\n    function isEqual(cursorA, cursorB) {\n        if (cursorA.type === 'position' && cursorB.type === 'position') {\n            return (cursorA.column === cursorB.column &&\n                cursorA.row === cursorB.row &&\n                cursorA.state === cursorB.state);\n        }\n        if (cursorA.type === 'range' && cursorB.type === 'range') {\n            return (cursorA.firstRow === cursorB.firstRow &&\n                cursorA.lastRow === cursorB.lastRow &&\n                (JSON.stringify(cursorA.columns) ===\n                    JSON.stringify(cursorB.columns)));\n        }\n        return false;\n    }\n    DataCursor.isEqual = isEqual;\n    /**\n     * Checks whether a cursor is in a range.\n     * @private\n     */\n    function isInRange(needle, range) {\n        if (range.type === 'position') {\n            range = toRange(range);\n        }\n        if (needle.type === 'position') {\n            needle = toRange(needle, range);\n        }\n        const needleColumns = needle.columns;\n        const rangeColumns = range.columns;\n        return (needle.firstRow >= range.firstRow &&\n            needle.lastRow <= range.lastRow &&\n            (!needleColumns ||\n                !rangeColumns ||\n                needleColumns.every((column) => rangeColumns.indexOf(column) >= 0)));\n    }\n    DataCursor.isInRange = isInRange;\n    /**\n     * @private\n     */\n    function toPositions(cursor) {\n        if (cursor.type === 'position') {\n            return [cursor];\n        }\n        const columns = (cursor.columns || []);\n        const positions = [];\n        const state = cursor.state;\n        for (let row = cursor.firstRow, rowEnd = cursor.lastRow; row < rowEnd; ++row) {\n            if (!columns.length) {\n                positions.push({\n                    type: 'position',\n                    row,\n                    state\n                });\n                continue;\n            }\n            for (let column = 0, columnEnd = columns.length; column < columnEnd; ++column) {\n                positions.push({\n                    type: 'position',\n                    column: columns[column],\n                    row,\n                    state\n                });\n            }\n        }\n        return positions;\n    }\n    DataCursor.toPositions = toPositions;\n    /**\n     * @private\n     */\n    function toRange(cursor, defaultRange) {\n        if (cursor.type === 'range') {\n            return cursor;\n        }\n        const range = {\n            type: 'range',\n            firstRow: (cursor.row ??\n                (defaultRange && defaultRange.firstRow) ??\n                0),\n            lastRow: (cursor.row ??\n                (defaultRange && defaultRange.lastRow) ??\n                Number.MAX_VALUE),\n            state: cursor.state\n        };\n        if (typeof cursor.column !== 'undefined') {\n            range.columns = [cursor.column];\n        }\n        return range;\n    }\n    DataCursor.toRange = toRange;\n})(DataCursor || (DataCursor = {}));\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Data_DataCursor = (DataCursor);\n\n;// ./code/es-modules/Data/DataPoolDefaults.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n/* *\n *\n *  API Options\n *\n * */\nconst DataPoolDefaults = {\n    connectors: []\n};\n/* *\n *\n *  Export Defaults\n *\n * */\n/* harmony default export */ const Data_DataPoolDefaults = (DataPoolDefaults);\n\n;// ./code/es-modules/Data/DataPool.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n\n\n/* *\n *\n *  Class\n *\n * */\n/**\n * Data pool to load connectors on-demand.\n *\n * @class\n * @name Data.DataPool\n *\n * @param {Data.DataPoolOptions} options\n * Pool options with all connectors.\n */\nclass DataPool {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    constructor(options = Data_DataPoolDefaults) {\n        options.connectors = (options.connectors || []);\n        this.connectors = {};\n        this.options = options;\n        this.waiting = {};\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Emits an event on this data pool to all registered callbacks of the given\n     * event.\n     * @private\n     *\n     * @param {DataTable.Event} e\n     * Event object with event information.\n     */\n    emit(e) {\n        highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().fireEvent(this, e.type, e);\n    }\n    /**\n     * Loads the connector.\n     *\n     * @function Data.DataPool#getConnector\n     *\n     * @param {string} connectorId\n     * ID of the connector.\n     *\n     * @return {Promise<Data.DataConnectorType>}\n     * Returns the connector.\n     */\n    getConnector(connectorId) {\n        const connector = this.connectors[connectorId];\n        // Already loaded\n        if (connector?.loaded) {\n            return Promise.resolve(connector);\n        }\n        let waitingList = this.waiting[connectorId];\n        // Start loading\n        if (!waitingList) {\n            waitingList = this.waiting[connectorId] = [];\n            const connectorOptions = this.getConnectorOptions(connectorId);\n            if (!connectorOptions) {\n                throw new Error(`Connector '${connectorId}' not found.`);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this\n                .loadConnector(connectorOptions)\n                .then((connector) => {\n                delete this.waiting[connectorId];\n                for (let i = 0, iEnd = waitingList.length; i < iEnd; ++i) {\n                    waitingList[i][0](connector);\n                }\n            })['catch']((error) => {\n                delete this.waiting[connectorId];\n                for (let i = 0, iEnd = waitingList.length; i < iEnd; ++i) {\n                    waitingList[i][1](error);\n                }\n            });\n        }\n        // Add request to waiting list\n        return new Promise((resolve, reject) => {\n            waitingList.push([resolve, reject]);\n        });\n    }\n    /**\n     * Returns the IDs of all connectors.\n     *\n     * @private\n     *\n     * @return {Array<string>}\n     * Names of all connectors.\n     */\n    getConnectorIds() {\n        const connectors = this.options.connectors, connectorIds = [];\n        for (let i = 0, iEnd = connectors.length; i < iEnd; ++i) {\n            connectorIds.push(connectors[i].id);\n        }\n        return connectorIds;\n    }\n    /**\n     * Loads the options of the connector.\n     *\n     * @private\n     *\n     * @param {string} connectorId\n     * ID of the connector.\n     *\n     * @return {DataPoolConnectorOptions|undefined}\n     * Returns the options of the connector, or `undefined` if not found.\n     */\n    getConnectorOptions(connectorId) {\n        const connectors = this.options.connectors;\n        for (let i = 0, iEnd = connectors.length; i < iEnd; ++i) {\n            if (connectors[i].id === connectorId) {\n                return connectors[i];\n            }\n        }\n    }\n    /**\n     * Loads the connector table.\n     *\n     * @function Data.DataPool#getConnectorTable\n     *\n     * @param {string} connectorId\n     * ID of the connector.\n     *\n     * @return {Promise<Data.DataTable>}\n     * Returns the connector table.\n     */\n    getConnectorTable(connectorId) {\n        return this\n            .getConnector(connectorId)\n            .then((connector) => connector.table);\n    }\n    /**\n     * Tests whether the connector has never been requested.\n     *\n     * @param {string} connectorId\n     * Name of the connector.\n     *\n     * @return {boolean}\n     * Returns `true`, if the connector has never been requested, otherwise\n     * `false`.\n     */\n    isNewConnector(connectorId) {\n        return !this.connectors[connectorId];\n    }\n    /**\n     * Creates and loads the connector.\n     *\n     * @private\n     *\n     * @param {Data.DataPoolConnectorOptions} options\n     * Options of connector.\n     *\n     * @return {Promise<Data.DataConnectorType>}\n     * Returns the connector.\n     */\n    loadConnector(options) {\n        return new Promise((resolve, reject) => {\n            this.emit({\n                type: 'load',\n                options\n            });\n            const ConnectorClass = Connectors_DataConnector.types[options.type];\n            if (!ConnectorClass) {\n                throw new Error(`Connector type not found. (${options.type})`);\n            }\n            const connector = this.connectors[options.id] = new ConnectorClass(options.options, options.dataTables);\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            connector\n                .load()\n                .then(({ converter, dataTables }) => {\n                connector.dataTables = dataTables;\n                connector.converter = converter;\n                connector.loaded = true;\n                this.emit({\n                    type: 'afterLoad',\n                    options\n                });\n                resolve(connector);\n            })['catch'](reject);\n        });\n    }\n    /**\n     * Cancels all data connectors pending requests.\n     */\n    cancelPendingRequests() {\n        const { connectors } = this;\n        for (const connectorKey of Object.keys(connectors)) {\n            connectors[connectorKey].stopPolling();\n        }\n    }\n    /**\n     * Registers a callback for a specific event.\n     *\n     * @function Highcharts.DataPool#on\n     *\n     * @param {string} type\n     * Event type as a string.\n     *\n     * @param {Highcharts.EventCallbackFunction<Highcharts.DataPool>} callback\n     * Function to register for an event callback.\n     *\n     * @return {Function}\n     * Function to unregister callback from the event.\n     */\n    on(type, callback) {\n        return highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().addEvent(this, type, callback);\n    }\n    /**\n     * Sets connector options under the specified `options.id`.\n     *\n     * @param {Data.DataPoolConnectorOptions} options\n     * Connector options to set.\n     */\n    setConnectorOptions(options) {\n        const connectors = this.options.connectors, instances = this.connectors;\n        this.emit({\n            type: 'setConnectorOptions',\n            options\n        });\n        for (let i = 0, iEnd = connectors.length; i < iEnd; ++i) {\n            if (connectors[i].id === options.id) {\n                connectors.splice(i, 1);\n                break;\n            }\n        }\n        if (instances[options.id]) {\n            instances[options.id].stopPolling();\n            delete instances[options.id];\n        }\n        connectors.push(options);\n        this.emit({\n            type: 'afterSetConnectorOptions',\n            options\n        });\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Semantic version string of the DataPool class.\n * @internal\n */\nDataPool.version = '1.0.0';\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Data_DataPool = (DataPool);\n\n;// ./code/es-modules/Data/Formula/FormulaParser.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { isString } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Constants\n *\n * */\n/**\n * @private\n */\nconst booleanRegExp = /^(?:FALSE|TRUE)/;\n/**\n * `.`-separated decimal.\n * @private\n */\nconst decimal1RegExp = /^[+\\-]?\\d+(?:\\.\\d+)?(?:e[+\\-]\\d+)?/;\n/**\n * `,`-separated decimal.\n * @private\n */\nconst decimal2RegExp = /^[+\\-]?\\d+(?:,\\d+)?(?:e[+\\-]\\d+)?/;\n/**\n * - Group 1: Function name\n * @private\n */\nconst functionRegExp = /^([A-Z][A-Z\\d\\.]*)\\(/;\n/**\n * @private\n */\nconst operatorRegExp = /^(?:[+\\-*\\/^<=>]|<=|=>)/;\n/**\n * - Group 1: Start column\n * - Group 2: Start row\n * - Group 3: End column\n * - Group 4: End row\n * @private\n */\nconst rangeA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)\\:(\\$?[A-Z]+)(\\$?\\d+)/;\n/**\n * - Group 1: Start row\n * - Group 2: Start column\n * - Group 3: End row\n * - Group 4: End column\n * @private\n */\nconst rangeR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])\\:R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])/;\n/**\n * - Group 1: Column\n * - Group 2: Row\n * @private\n */\nconst referenceA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)(?![\\:C])/;\n/**\n * - Group 1: Row\n * - Group 2: Column\n * @private\n */\nconst referenceR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])(?!\\:)/;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Extracts the inner string of the most outer parantheses.\n *\n * @private\n *\n * @param {string} text\n * Text string to extract from.\n *\n * @return {string}\n * Extracted parantheses. If not found an exception will be thrown.\n */\nfunction extractParantheses(text) {\n    let parantheseLevel = 0;\n    for (let i = 0, iEnd = text.length, char, parantheseStart = 1; i < iEnd; ++i) {\n        char = text[i];\n        if (char === '(') {\n            if (!parantheseLevel) {\n                parantheseStart = i + 1;\n            }\n            ++parantheseLevel;\n            continue;\n        }\n        if (char === ')') {\n            --parantheseLevel;\n            if (!parantheseLevel) {\n                return text.substring(parantheseStart, i);\n            }\n        }\n    }\n    if (parantheseLevel > 0) {\n        const error = new Error('Incomplete parantheses.');\n        error.name = 'FormulaParseError';\n        throw error;\n    }\n    return '';\n}\n/**\n * Extracts the inner string value.\n *\n * @private\n *\n * @param {string} text\n * Text string to extract from.\n *\n * @return {string}\n * Extracted string. If not found an exception will be thrown.\n */\nfunction extractString(text) {\n    let start = -1;\n    for (let i = 0, iEnd = text.length, char, escaping = false; i < iEnd; ++i) {\n        char = text[i];\n        if (char === '\\\\') {\n            escaping = !escaping;\n            continue;\n        }\n        if (escaping) {\n            escaping = false;\n            continue;\n        }\n        if (char === '\"') {\n            if (start < 0) {\n                start = i;\n            }\n            else {\n                return text.substring(start + 1, i); // `Ã¬` is excluding\n            }\n        }\n    }\n    const error = new Error('Incomplete string.');\n    error.name = 'FormulaParseError';\n    throw error;\n}\n/**\n * Parses an argument string. Formula arrays with a single term will be\n * simplified to the term.\n *\n * @private\n *\n * @param {string} text\n * Argument string to parse.\n *\n * @param {boolean} alternativeSeparators\n * Whether to expect `;` as argument separator and `,` as decimal separator.\n *\n * @return {Formula|Function|Range|Reference|Value}\n * The recognized term structure.\n */\nfunction parseArgument(text, alternativeSeparators) {\n    let match;\n    // Check for a R1C1:R1C1 range notation\n    match = text.match(rangeR1C1RegExp);\n    if (match) {\n        const beginColumnRelative = (match[2] === '' || match[2][0] === '[');\n        const beginRowRelative = (match[1] === '' || match[1][0] === '[');\n        const endColumnRelative = (match[4] === '' || match[4][0] === '[');\n        const endRowRelative = (match[3] === '' || match[3][0] === '[');\n        const range = {\n            type: 'range',\n            beginColumn: (beginColumnRelative ?\n                parseInt(match[2].substring(1, -1) || '0', 10) :\n                parseInt(match[2], 10) - 1),\n            beginRow: (beginRowRelative ?\n                parseInt(match[1].substring(1, -1) || '0', 10) :\n                parseInt(match[1], 10) - 1),\n            endColumn: (endColumnRelative ?\n                parseInt(match[4].substring(1, -1) || '0', 10) :\n                parseInt(match[4], 10) - 1),\n            endRow: (endRowRelative ?\n                parseInt(match[3].substring(1, -1) || '0', 10) :\n                parseInt(match[3], 10) - 1)\n        };\n        if (beginColumnRelative) {\n            range.beginColumnRelative = true;\n        }\n        if (beginRowRelative) {\n            range.beginRowRelative = true;\n        }\n        if (endColumnRelative) {\n            range.endColumnRelative = true;\n        }\n        if (endRowRelative) {\n            range.endRowRelative = true;\n        }\n        return range;\n    }\n    // Check for a A1:A1 range notation\n    match = text.match(rangeA1RegExp);\n    if (match) {\n        const beginColumnRelative = match[1][0] !== '$';\n        const beginRowRelative = match[2][0] !== '$';\n        const endColumnRelative = match[3][0] !== '$';\n        const endRowRelative = match[4][0] !== '$';\n        const range = {\n            type: 'range',\n            beginColumn: parseReferenceColumn(beginColumnRelative ?\n                match[1] :\n                match[1].substring(1)) - 1,\n            beginRow: parseInt(beginRowRelative ?\n                match[2] :\n                match[2].substring(1), 10) - 1,\n            endColumn: parseReferenceColumn(endColumnRelative ?\n                match[3] :\n                match[3].substring(1)) - 1,\n            endRow: parseInt(endRowRelative ?\n                match[4] :\n                match[4].substring(1), 10) - 1\n        };\n        if (beginColumnRelative) {\n            range.beginColumnRelative = true;\n        }\n        if (beginRowRelative) {\n            range.beginRowRelative = true;\n        }\n        if (endColumnRelative) {\n            range.endColumnRelative = true;\n        }\n        if (endRowRelative) {\n            range.endRowRelative = true;\n        }\n        return range;\n    }\n    // Fallback to formula processing for other pattern types\n    const formula = parseFormula(text, alternativeSeparators);\n    return (formula.length === 1 && typeof formula[0] !== 'string' ?\n        formula[0] :\n        formula);\n}\n/**\n * Parse arguments string inside function parantheses.\n *\n * @private\n *\n * @param {string} text\n * Parantheses string of the function.\n *\n * @param {boolean} alternativeSeparators\n * Whether to expect `;` as argument separator and `,` as decimal separator.\n *\n * @return {Highcharts.FormulaArguments}\n * Parsed arguments array.\n */\nfunction parseArguments(text, alternativeSeparators) {\n    const args = [], argumentsSeparator = (alternativeSeparators ? ';' : ',');\n    let parantheseLevel = 0, term = '';\n    for (let i = 0, iEnd = text.length, char; i < iEnd; ++i) {\n        char = text[i];\n        // Check for separator\n        if (char === argumentsSeparator &&\n            !parantheseLevel &&\n            term) {\n            args.push(parseArgument(term, alternativeSeparators));\n            term = '';\n            // Check for a quoted string before skip logic\n        }\n        else if (char === '\"' &&\n            !parantheseLevel &&\n            !term) {\n            const string = extractString(text.substring(i));\n            args.push(string);\n            i += string.length + 1; // Only +1 to cover ++i in for-loop\n            // Skip space and check paranthesis nesting\n        }\n        else if (char !== ' ') {\n            term += char;\n            if (char === '(') {\n                ++parantheseLevel;\n            }\n            else if (char === ')') {\n                --parantheseLevel;\n            }\n        }\n    }\n    // Look for left-overs from last argument\n    if (!parantheseLevel && term) {\n        args.push(parseArgument(term, alternativeSeparators));\n    }\n    return args;\n}\n/**\n * Checks if there's one of the following operator before the negative number\n * value: '*', '/' or '^'.\n *\n * Used to properly indicate a negative value reference or negate a directly\n * passed number value.\n */\nfunction negativeReference(formula) {\n    const formulaLength = formula.length;\n    const priorFormula = formula[formulaLength - 2];\n    return (formula[formulaLength - 1] === '-' &&\n        isString(priorFormula) &&\n        !!priorFormula.match(/\\*|\\/|\\^/));\n}\n/**\n * Converts a spreadsheet formula string into a formula array. Throws a\n * `FormulaParserError` when the string can not be parsed.\n *\n * @private\n * @function Formula.parseFormula\n *\n * @param {string} text\n * Spreadsheet formula string, without the leading `=`.\n *\n * @param {boolean} alternativeSeparators\n * * `false` to expect `,` between arguments and `.` in decimals.\n * * `true` to expect `;` between arguments and `,` in decimals.\n *\n * @return {Formula.Formula}\n * Formula array representing the string.\n */\nfunction parseFormula(text, alternativeSeparators) {\n    const decimalRegExp = (alternativeSeparators ?\n        decimal2RegExp :\n        decimal1RegExp), formula = [];\n    let match, next = (text[0] === '=' ? text.substring(1) : text).trim();\n    while (next) {\n        // Check for an R1C1 reference notation\n        match = next.match(referenceR1C1RegExp);\n        if (match) {\n            const columnRelative = (match[2] === '' || match[2][0] === '[');\n            const rowRelative = (match[1] === '' || match[1][0] === '[');\n            const reference = {\n                type: 'reference',\n                column: (columnRelative ?\n                    parseInt(match[2].substring(1, -1) || '0', 10) :\n                    parseInt(match[2], 10) - 1),\n                row: (rowRelative ?\n                    parseInt(match[1].substring(1, -1) || '0', 10) :\n                    parseInt(match[1], 10) - 1)\n            };\n            if (columnRelative) {\n                reference.columnRelative = true;\n            }\n            if (rowRelative) {\n                reference.rowRelative = true;\n            }\n            if (negativeReference(formula)) {\n                formula.pop();\n                reference.isNegative = true;\n            }\n            formula.push(reference);\n            next = next.substring(match[0].length).trim();\n            continue;\n        }\n        // Check for an A1 reference notation\n        match = next.match(referenceA1RegExp);\n        if (match) {\n            const columnRelative = match[1][0] !== '$';\n            const rowRelative = match[2][0] !== '$';\n            const reference = {\n                type: 'reference',\n                column: parseReferenceColumn(columnRelative ?\n                    match[1] :\n                    match[1].substring(1)) - 1,\n                row: parseInt(rowRelative ?\n                    match[2] :\n                    match[2].substring(1), 10) - 1\n            };\n            if (columnRelative) {\n                reference.columnRelative = true;\n            }\n            if (rowRelative) {\n                reference.rowRelative = true;\n            }\n            if (negativeReference(formula)) {\n                formula.pop();\n                reference.isNegative = true;\n            }\n            formula.push(reference);\n            next = next.substring(match[0].length).trim();\n            continue;\n        }\n        // Check for a formula operator\n        match = next.match(operatorRegExp);\n        if (match) {\n            formula.push(match[0]);\n            next = next.substring(match[0].length).trim();\n            continue;\n        }\n        // Check for a boolean value\n        match = next.match(booleanRegExp);\n        if (match) {\n            formula.push(match[0] === 'TRUE');\n            next = next.substring(match[0].length).trim();\n            continue;\n        }\n        // Check for a number value\n        match = next.match(decimalRegExp);\n        if (match) {\n            let number = parseFloat(match[0]);\n            // If the current value is multiplication-related and the previous\n            // one is a minus sign, set the current value to negative and remove\n            // the minus sign.\n            if (negativeReference(formula)) {\n                formula.pop();\n                number = -number;\n            }\n            formula.push(number);\n            next = next.substring(match[0].length).trim();\n            continue;\n        }\n        // Check for a quoted string\n        if (next[0] === '\"') {\n            const string = extractString(next);\n            formula.push(string.substring(1, -1));\n            next = next.substring(string.length + 2).trim();\n            continue;\n        }\n        // Check for a function\n        match = next.match(functionRegExp);\n        if (match) {\n            next = next.substring(match[1].length).trim();\n            const parantheses = extractParantheses(next);\n            formula.push({\n                type: 'function',\n                name: match[1],\n                args: parseArguments(parantheses, alternativeSeparators)\n            });\n            next = next.substring(parantheses.length + 2).trim();\n            continue;\n        }\n        // Check for a formula in parantheses\n        if (next[0] === '(') {\n            const paranteses = extractParantheses(next);\n            if (paranteses) {\n                formula\n                    .push(parseFormula(paranteses, alternativeSeparators));\n                next = next.substring(paranteses.length + 2).trim();\n                continue;\n            }\n        }\n        // Something is not right\n        const position = text.length - next.length, error = new Error('Unexpected character `' +\n            text.substring(position, position + 1) +\n            '` at position ' + (position + 1) +\n            '. (`...' + text.substring(position - 5, position + 6) + '...`)');\n        error.name = 'FormulaParseError';\n        throw error;\n    }\n    return formula;\n}\n/**\n * Converts a reference column `A` of `A1` into a number. Supports endless sizes\n * `ZZZ...`, just limited by integer precision.\n *\n * @private\n *\n * @param {string} text\n * Column string to convert.\n *\n * @return {number}\n * Converted column index.\n */\nfunction parseReferenceColumn(text) {\n    let column = 0;\n    for (let i = 0, iEnd = text.length, code, factor = text.length - 1; i < iEnd; ++i) {\n        code = text.charCodeAt(i);\n        if (code >= 65 && code <= 90) {\n            column += (code - 64) * Math.pow(26, factor);\n        }\n        --factor;\n    }\n    return column;\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst FormulaParser = {\n    parseFormula\n};\n/* harmony default export */ const Formula_FormulaParser = (FormulaParser);\n\n;// ./code/es-modules/Data/Formula/FormulaTypes.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n/* *\n *\n *  Constants\n *\n * */\n/**\n * Array of all possible operators.\n * @private\n */\nconst operators = ['+', '-', '*', '/', '^', '=', '<', '<=', '>', '>='];\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Tests an item for a Formula array.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is a formula (or argument) array.\n */\nfunction isFormula(item) {\n    return item instanceof Array;\n}\n/**\n * Tests an item for a Function structure.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is a formula function.\n */\nfunction isFunction(item) {\n    return (typeof item === 'object' &&\n        !(item instanceof Array) &&\n        item.type === 'function');\n}\n/**\n * Tests an item for an Operator string.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is an operator string.\n */\nfunction isOperator(item) {\n    return (typeof item === 'string' &&\n        operators.indexOf(item) >= 0);\n}\n/**\n * Tests an item for a Range structure.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is a range.\n */\nfunction isRange(item) {\n    return (typeof item === 'object' &&\n        !(item instanceof Array) &&\n        item.type === 'range');\n}\n/**\n * Tests an item for a Reference structure.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is a reference.\n */\nfunction isReference(item) {\n    return (typeof item === 'object' &&\n        !(item instanceof Array) &&\n        item.type === 'reference');\n}\n/**\n * Tests an item for a Value structure.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem|null|undefined} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is a value.\n */\nfunction isValue(item) {\n    return (typeof item === 'boolean' ||\n        typeof item === 'number' ||\n        typeof item === 'string');\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst MathFormula = {\n    isFormula,\n    isFunction,\n    isOperator,\n    isRange,\n    isReference,\n    isValue\n};\n/* harmony default export */ const FormulaTypes = (MathFormula);\n\n;// ./code/es-modules/Data/Formula/FormulaProcessor.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { isFormula: FormulaProcessor_isFormula, isFunction: FormulaProcessor_isFunction, isOperator: FormulaProcessor_isOperator, isRange: FormulaProcessor_isRange, isReference: FormulaProcessor_isReference, isValue: FormulaProcessor_isValue } = FormulaTypes;\n\nconst { defined: FormulaProcessor_defined } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Constants\n *\n * */\nconst asLogicalStringRegExp = / */;\nconst MAX_FALSE = Number.MAX_VALUE / 1.000000000001;\nconst MAX_STRING = Number.MAX_VALUE / 1.000000000002;\nconst MAX_TRUE = Number.MAX_VALUE;\nconst operatorPriority = {\n    '^': 3,\n    '*': 2,\n    '/': 2,\n    '+': 1,\n    '-': 1,\n    '=': 0,\n    '<': 0,\n    '<=': 0,\n    '>': 0,\n    '>=': 0\n};\nconst processorFunctions = {};\nconst processorFunctionNameRegExp = /^[A-Z][A-Z\\.]*$/;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Converts non-number types to logical numbers.\n *\n * @param {Highcharts.FormulaValue} value\n * Value to convert.\n *\n * @return {number}\n * Logical number value. `NaN` if not convertable.\n */\nfunction asLogicalNumber(value) {\n    switch (typeof value) {\n        case 'boolean':\n            return value ? MAX_TRUE : MAX_FALSE;\n        case 'string':\n            return MAX_STRING;\n        case 'number':\n            return value;\n        default:\n            return NaN;\n    }\n}\n/**\n * Converts strings to logical strings, while other types get passed through. In\n * logical strings the space character is the lowest value and letters are case\n * insensitive.\n *\n * @param {Highcharts.FormulaValue} value\n * Value to convert.\n *\n * @return {Highcharts.FormulaValue}\n * Logical string value or passed through value.\n */\nfunction asLogicalString(value) {\n    if (typeof value === 'string') {\n        return value.toLowerCase().replace(asLogicalStringRegExp, '\\0');\n    }\n    return value;\n}\n/**\n * Converts non-number types to a logic number.\n *\n * @param {Highcharts.FormulaValue} value\n * Value to convert.\n *\n * @return {number}\n * Number value. `NaN` if not convertable.\n */\nfunction asNumber(value) {\n    switch (typeof value) {\n        case 'boolean':\n            return value ? 1 : 0;\n        case 'string':\n            return parseFloat(value.replace(',', '.'));\n        case 'number':\n            return value;\n        default:\n            return NaN;\n    }\n}\n/**\n * Process a basic operation of two given values.\n *\n * @private\n *\n * @param {Highcharts.FormulaOperator} operator\n * Operator between values.\n *\n * @param {Highcharts.FormulaValue} x\n * First value for operation.\n *\n * @param {Highcharts.FormulaValue} y\n * Second value for operation.\n *\n * @return {Highcharts.FormulaValue}\n * Operation result. `NaN` if operation is not support.\n */\nfunction basicOperation(operator, x, y) {\n    switch (operator) {\n        case '=':\n            return asLogicalString(x) === asLogicalString(y);\n        case '<':\n            if (typeof x === typeof y) {\n                return asLogicalString(x) < asLogicalString(y);\n            }\n            return asLogicalNumber(x) < asLogicalNumber(y);\n        case '<=':\n            if (typeof x === typeof y) {\n                return asLogicalString(x) <= asLogicalString(y);\n            }\n            return asLogicalNumber(x) <= asLogicalNumber(y);\n        case '>':\n            if (typeof x === typeof y) {\n                return asLogicalString(x) > asLogicalString(y);\n            }\n            return asLogicalNumber(x) > asLogicalNumber(y);\n        case '>=':\n            if (typeof x === typeof y) {\n                return asLogicalString(x) >= asLogicalString(y);\n            }\n            return asLogicalNumber(x) >= asLogicalNumber(y);\n    }\n    x = asNumber(x);\n    y = asNumber(y);\n    let result;\n    switch (operator) {\n        case '+':\n            result = x + y;\n            break;\n        case '-':\n            result = x - y;\n            break;\n        case '*':\n            result = x * y;\n            break;\n        case '/':\n            result = x / y;\n            break;\n        case '^':\n            result = Math.pow(x, y);\n            break;\n        default:\n            return NaN;\n    }\n    // Limit decimal to 9 digits\n    return (result % 1 ?\n        Math.round(result * 1000000000) / 1000000000 :\n        result);\n}\n/**\n * Converts an argument to Value and in case of a range to an array of Values.\n *\n * @function Highcharts.Formula.getArgumentValue\n *\n * @param {Highcharts.FormulaRange|Highcharts.FormulaTerm} arg\n * Formula range or term to convert.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n * Converted value.\n */\nfunction getArgumentValue(arg, table) {\n    // Add value\n    if (FormulaProcessor_isValue(arg)) {\n        return arg;\n    }\n    // Add values of a range\n    if (FormulaProcessor_isRange(arg)) {\n        return (table && getRangeValues(arg, table) || []);\n    }\n    // Add values of a function\n    if (FormulaProcessor_isFunction(arg)) {\n        return processFunction(arg, table);\n    }\n    // Process functions, operations, references with formula processor\n    return processFormula((FormulaProcessor_isFormula(arg) ? arg : [arg]), table);\n}\n/**\n * Converts all arguments to Values and in case of ranges to arrays of Values.\n *\n * @function Highcharts.Formula.getArgumentsValues\n *\n * @param {Highcharts.FormulaArguments} args\n * Formula arguments to convert.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {Array<(Highcharts.FormulaValue|Array<Highcharts.FormulaValue>)>}\n * Converted values.\n */\nfunction getArgumentsValues(args, table) {\n    const values = [];\n    for (let i = 0, iEnd = args.length; i < iEnd; ++i) {\n        values.push(getArgumentValue(args[i], table));\n    }\n    return values;\n}\n/**\n * Extracts cell values from a table for a given range.\n *\n * @function Highcharts.Formula.getRangeValues\n *\n * @param {Highcharts.FormulaRange} range\n * Formula range to use.\n *\n * @param {Highcharts.DataTable} table\n * Table to extract from.\n *\n * @return {Array<Highcharts.FormulaValue>}\n * Extracted values.\n */\nfunction getRangeValues(range, table) {\n    const columnNames = table\n        .getColumnNames()\n        .slice(range.beginColumn, range.endColumn + 1), values = [];\n    for (let i = 0, iEnd = columnNames.length, cell; i < iEnd; ++i) {\n        const cells = table.getColumn(columnNames[i], true) || [];\n        for (let j = range.beginRow, jEnd = range.endRow + 1; j < jEnd; ++j) {\n            cell = cells[j];\n            if (typeof cell === 'string' &&\n                cell[0] === '=' &&\n                table !== table.modified) {\n                // Look in the modified table for formula result\n                cell = table.modified.getCell(columnNames[i], j);\n            }\n            values.push(FormulaProcessor_isValue(cell) ? cell : NaN);\n        }\n    }\n    return values;\n}\n/**\n * Extracts the cell value from a table for a given reference.\n *\n * @private\n *\n * @param {Highcharts.FormulaReference} reference\n * Formula reference to use.\n *\n * @param {Highcharts.DataTable} table\n * Table to extract from.\n *\n * @return {Highcharts.FormulaValue}\n * Extracted value. 'undefined' might also indicate that the cell was not found.\n */\nfunction getReferenceValue(reference, table) {\n    const columnName = table.getColumnNames()[reference.column];\n    if (columnName) {\n        const cell = table.getCell(columnName, reference.row);\n        if (typeof cell === 'string' &&\n            cell[0] === '=' &&\n            table !== table.modified) {\n            // Look in the modified table for formula result\n            const result = table.modified.getCell(columnName, reference.row);\n            return FormulaProcessor_isValue(result) ? result : NaN;\n        }\n        if (FormulaProcessor_isValue(cell)) {\n            return reference.isNegative ? -cell : cell;\n        }\n        return NaN;\n    }\n    return NaN;\n}\n/**\n * Calculates a value based on the two top values and the related operator.\n *\n * Used to properly process the formula's values based on its operators.\n *\n * @private\n * @function Highcharts.applyOperator\n *\n * @param {Array<Highcharts.Value>} values\n * Processed formula values.\n *\n * @param {Array<Highcharts.Operator>} operators\n * Processed formula operators.\n */\nfunction applyOperator(values, operators) {\n    if (values.length < 2 || operators.length < 1) {\n        values.push(NaN);\n    }\n    const secondValue = values.pop();\n    const firstValue = values.pop();\n    const operator = operators.pop();\n    if (!FormulaProcessor_defined(secondValue) || !FormulaProcessor_defined(firstValue) || !FormulaProcessor_defined(operator)) {\n        values.push(NaN);\n    }\n    else {\n        values.push(basicOperation(operator, firstValue, secondValue));\n    }\n}\n/**\n * Processes a formula array on the given table. If the formula does not contain\n * references or ranges, then no table has to be provided.\n *\n * Performs formulas considering the operators precedence.\n *\n * // Example of the `2 * 3 + 4` formula:\n * 2 -> values: [2], operators: []\n * * -> values: [2], operators: [*]\n * 3 -> values: [2, 3], operators: [*]\n * // Since the higher precedence operator exists (* > +), perform it first.\n * + -> values: [6], operators: [+]\n * 4 -> values: [6, 4], operators: [+]\n * // When non-higher precedence operators remain, perform rest calculations.\n * -> values: [10], operators: []\n *\n * @private\n * @function Highcharts.processFormula\n *\n * @param {Highcharts.Formula} formula\n * Formula array to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {Highcharts.FormulaValue}\n * Result value of the process. `NaN` indicates an error.\n */\nfunction processFormula(formula, table) {\n    // Keeps all the values to calculate them in a proper priority, based on the\n    // given operators.\n    const values = [];\n    // Keeps all the operators to calculate the values above, following the\n    // proper priority.\n    const operators = [];\n    // Indicates if the next item is a value (not an operator).\n    let expectingValue = true;\n    for (let i = 0, iEnd = formula.length; i < iEnd; ++i) {\n        const item = formula[i];\n        if (FormulaProcessor_isOperator(item)) {\n            if (expectingValue && item === '-') {\n                // Split the negative values to be handled as a binary\n                // operation if the next item is a value.\n                values.push(0);\n                operators.push('-');\n                expectingValue = true;\n            }\n            else {\n                // Perform if the higher precedence operator exist.\n                while (operators.length &&\n                    operatorPriority[operators[operators.length - 1]] >=\n                        operatorPriority[item]) {\n                    applyOperator(values, operators);\n                }\n                operators.push(item);\n                expectingValue = true;\n            }\n            continue;\n        }\n        let value;\n        // Assign the proper value, starting from the most common types.\n        if (FormulaProcessor_isValue(item)) {\n            value = item;\n        }\n        else if (FormulaProcessor_isReference(item)) {\n            value = table ? getReferenceValue(item, table) : NaN;\n        }\n        else if (FormulaProcessor_isFunction(item)) {\n            const result = processFunction(item, table);\n            value = FormulaProcessor_isValue(result) ? result : NaN;\n        }\n        else if (FormulaProcessor_isFormula(item)) {\n            value = processFormula(item, table);\n        }\n        if (typeof value !== 'undefined') {\n            values.push(value);\n            expectingValue = false;\n        }\n        else {\n            return NaN;\n        }\n    }\n    // Handle the remaining operators that weren't taken into consideration, due\n    // to non-higher precedence.\n    while (operators.length) {\n        applyOperator(values, operators);\n    }\n    if (values.length !== 1) {\n        return NaN;\n    }\n    return values[0];\n}\n/**\n * Process a function on the given table. If the arguments do not contain\n * references or ranges, then no table has to be provided.\n *\n * @private\n *\n * @param {Highcharts.FormulaFunction} formulaFunction\n * Formula function to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @param {Highcharts.FormulaReference} [reference]\n * Table cell reference to use for relative references and ranges.\n *\n * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n * Result value (or values) of the process. `NaN` indicates an error.\n */\nfunction processFunction(formulaFunction, table, \n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nreference // @todo\n) {\n    const processor = processorFunctions[formulaFunction.name];\n    if (processor) {\n        try {\n            return processor(formulaFunction.args, table);\n        }\n        catch {\n            return NaN;\n        }\n    }\n    const error = new Error(`Function \"${formulaFunction.name}\" not found.`);\n    error.name = 'FormulaProcessError';\n    throw error;\n}\n/**\n * Registers a function for the FormulaProcessor.\n *\n * @param {string} name\n * Name of the function in spreadsheets notation with upper case.\n *\n * @param {Highcharts.FormulaFunction} processorFunction\n * ProcessorFunction for the FormulaProcessor. This is an object so that it\n * can take additional parameter for future validation routines.\n *\n * @return {boolean}\n * Return true, if the ProcessorFunction has been registered.\n */\nfunction registerProcessorFunction(name, processorFunction) {\n    return (processorFunctionNameRegExp.test(name) &&\n        !processorFunctions[name] &&\n        !!(processorFunctions[name] = processorFunction));\n}\n/**\n * Translates relative references and ranges in-place.\n *\n * @param {Highcharts.Formula} formula\n * Formula to translate references and ranges in.\n *\n * @param {number} [columnDelta=0]\n * Column delta to translate to. Negative translate back.\n *\n * @param {number} [rowDelta=0]\n * Row delta to translate to. Negative numbers translate back.\n *\n * @return {Highcharts.Formula}\n * Formula with translated reference and ranges. This formula is equal to the\n * first argument.\n */\nfunction translateReferences(formula, columnDelta = 0, rowDelta = 0) {\n    for (let i = 0, iEnd = formula.length, item; i < iEnd; ++i) {\n        item = formula[i];\n        if (item instanceof Array) {\n            translateReferences(item, columnDelta, rowDelta);\n        }\n        else if (FormulaProcessor_isFunction(item)) {\n            translateReferences(item.args, columnDelta, rowDelta);\n        }\n        else if (FormulaProcessor_isRange(item)) {\n            if (item.beginColumnRelative) {\n                item.beginColumn += columnDelta;\n            }\n            if (item.beginRowRelative) {\n                item.beginRow += rowDelta;\n            }\n            if (item.endColumnRelative) {\n                item.endColumn += columnDelta;\n            }\n            if (item.endRowRelative) {\n                item.endRow += rowDelta;\n            }\n        }\n        else if (FormulaProcessor_isReference(item)) {\n            if (item.columnRelative) {\n                item.column += columnDelta;\n            }\n            if (item.rowRelative) {\n                item.row += rowDelta;\n            }\n        }\n    }\n    return formula;\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst FormulaProcessor = {\n    asNumber,\n    getArgumentValue,\n    getArgumentsValues,\n    getRangeValues,\n    getReferenceValue,\n    processFormula,\n    processorFunctions,\n    registerProcessorFunction,\n    translateReferences\n};\n/* harmony default export */ const Formula_FormulaProcessor = (FormulaProcessor);\n\n;// ./code/es-modules/Data/Formula/Functions/ABS.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: ABS_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `ABS(value)` implementation. Returns positive numbers.\n *\n * @private\n * @function Formula.processorFunctions.AND\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {Array<number>}\n * Result value of the process.\n */\nfunction ABS(args, table) {\n    const value = ABS_getArgumentValue(args[0], table);\n    switch (typeof value) {\n        case 'number':\n            return Math.abs(value);\n        case 'object': {\n            const values = [];\n            for (let i = 0, iEnd = value.length, value2; i < iEnd; ++i) {\n                value2 = value[i];\n                if (typeof value2 !== 'number') {\n                    return NaN;\n                }\n                values.push(Math.abs(value2));\n            }\n            return values;\n        }\n        default:\n            return NaN;\n    }\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('ABS', ABS);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_ABS = ((/* unused pure expression or super */ null && (ABS)));\n\n;// ./code/es-modules/Data/Formula/Functions/AND.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: AND_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `AND(...tests)` implementation. Returns `TRUE`, if all test\n * results are not `0` or `FALSE`.\n *\n * @private\n * @function Formula.processorFunctions.AND\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {boolean}\n * Result value of the process.\n */\nfunction AND(args, table) {\n    for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n        value = AND_getArgumentValue(args[i], table);\n        if (!value ||\n            (typeof value === 'object' &&\n                !AND(value, table))) {\n            return false;\n        }\n    }\n    return true;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('AND', AND);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_AND = ((/* unused pure expression or super */ null && (AND)));\n\n;// ./code/es-modules/Data/Formula/Functions/AVERAGE.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentsValues: AVERAGE_getArgumentsValues } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `AVERAGE(...values)` implementation. Calculates the average\n * of the given values that are numbers.\n *\n * @private\n * @function Formula.processorFunctions.AVERAGE\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction AVERAGE(args, table) {\n    const values = AVERAGE_getArgumentsValues(args, table);\n    let count = 0, result = 0;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    ++count;\n                    result += value;\n                }\n                break;\n            case 'object':\n                for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                    value2 = value[j];\n                    if (typeof value2 === 'number' &&\n                        !isNaN(value2)) {\n                        ++count;\n                        result += value2;\n                    }\n                }\n                break;\n        }\n    }\n    return (count ? (result / count) : 0);\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('AVERAGE', AVERAGE);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_AVERAGE = ((/* unused pure expression or super */ null && (AVERAGE)));\n\n;// ./code/es-modules/Data/Formula/Functions/AVERAGEA.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: AVERAGEA_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `AVERAGEA(...values)` implementation. Calculates the\n * average of the given values. Strings and FALSE are calculated as 0.\n *\n * @private\n * @function Formula.processorFunctions.AVERAGEA\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction AVERAGEA(args, table) {\n    let count = 0, result = 0;\n    for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n        value = AVERAGEA_getArgumentValue(args[i], table);\n        switch (typeof value) {\n            case 'boolean':\n                ++count;\n                result += (value ? 1 : 0);\n                continue;\n            case 'number':\n                if (!isNaN(value)) {\n                    ++count;\n                    result += value;\n                }\n                continue;\n            case 'string':\n                ++count;\n                continue;\n            default:\n                for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                    value2 = value[j];\n                    switch (typeof value2) {\n                        case 'boolean':\n                            ++count;\n                            result += (value2 ? 1 : 0);\n                            continue;\n                        case 'number':\n                            if (!isNaN(value2)) {\n                                ++count;\n                                result += value2;\n                            }\n                            continue;\n                        case 'string':\n                            ++count;\n                            continue;\n                    }\n                }\n                continue;\n        }\n    }\n    return (count ? (result / count) : 0);\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('AVERAGEA', AVERAGEA);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_AVERAGEA = ((/* unused pure expression or super */ null && (AVERAGEA)));\n\n;// ./code/es-modules/Data/Formula/Functions/COUNT.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `COUNT(...values)` implementation. Returns the count of\n * given values that are numbers.\n *\n * @private\n * @function Formula.processorFunctions.COUNT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction COUNT(args, table) {\n    const values = Formula_FormulaProcessor.getArgumentsValues(args, table);\n    let count = 0;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    ++count;\n                }\n                break;\n            case 'object':\n                count += COUNT(value, table);\n                break;\n        }\n    }\n    return count;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('COUNT', COUNT);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_COUNT = ((/* unused pure expression or super */ null && (COUNT)));\n\n;// ./code/es-modules/Data/Formula/Functions/COUNTA.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `COUNTA(...values)` implementation. Returns the count of\n * given values that are not empty.\n *\n * @private\n * @function Formula.processorFunctions.COUNT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction COUNTA(args, table) {\n    const values = Formula_FormulaProcessor.getArgumentsValues(args, table);\n    let count = 0;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (isNaN(value)) {\n                    continue;\n                }\n                break;\n            case 'object':\n                count += COUNTA(value, table);\n                continue;\n            case 'string':\n                if (!value) {\n                    continue;\n                }\n                break;\n        }\n        ++count;\n    }\n    return count;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('COUNTA', COUNTA);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_COUNTA = ((/* unused pure expression or super */ null && (COUNTA)));\n\n;// ./code/es-modules/Data/Formula/Functions/IF.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: IF_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `IF(test, value1, value2)` implementation. Returns one of\n * the values based on the test result. `value1` will be returned, if the test\n * result is not `0` or `FALSE`.\n *\n * @private\n * @function Formula.processorFunctions.IF\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n * Result value of the process.\n */\nfunction IF(args, table) {\n    return (IF_getArgumentValue(args[0], table) ?\n        IF_getArgumentValue(args[1], table) :\n        IF_getArgumentValue(args[2], table));\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('IF', IF);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_IF = ((/* unused pure expression or super */ null && (IF)));\n\n;// ./code/es-modules/Data/Formula/Functions/ISNA.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: ISNA_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `ISNA(value)` implementation. Returns TRUE if value is not\n * a number.\n *\n * @private\n * @function Formula.processorFunctions.ISNA\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {boolean}\n * Result value of the process.\n */\nfunction ISNA(args, table) {\n    const value = ISNA_getArgumentValue(args[0], table);\n    return (typeof value !== 'number' || isNaN(value));\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('ISNA', ISNA);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_ISNA = ((/* unused pure expression or super */ null && (ISNA)));\n\n;// ./code/es-modules/Data/Formula/Functions/MAX.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentsValues: MAX_getArgumentsValues } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `MAX(...values)` implementation. Calculates the largest\n * of the given values that are numbers.\n *\n * @private\n * @function Formula.processorFunctions.MAX\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction MAX(args, table) {\n    const values = MAX_getArgumentsValues(args, table);\n    let result = Number.NEGATIVE_INFINITY;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (value > result) {\n                    result = value;\n                }\n                break;\n            case 'object':\n                value = MAX(value);\n                if (value > result) {\n                    result = value;\n                }\n                break;\n        }\n    }\n    return isFinite(result) ? result : 0;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('MAX', MAX);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_MAX = ((/* unused pure expression or super */ null && (MAX)));\n\n;// ./code/es-modules/Data/Formula/Functions/MEDIAN.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `MEDIAN(...values)` implementation. Calculates the median\n * average of the given values.\n *\n * @private\n * @function Formula.processorFunctions.MEDIAN\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to process.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction MEDIAN(args, table) {\n    const median = [], values = Formula_FormulaProcessor.getArgumentsValues(args, table);\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    median.push(value);\n                }\n                break;\n            case 'object':\n                for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                    value2 = value[j];\n                    if (typeof value2 === 'number' &&\n                        !isNaN(value2)) {\n                        median.push(value2);\n                    }\n                }\n                break;\n        }\n    }\n    const count = median.length;\n    if (!count) {\n        return NaN;\n    }\n    const half = Math.floor(count / 2); // Floor because index starts at 0\n    return (count % 2 ?\n        median[half] : // Odd\n        (median[half - 1] + median[half]) / 2 // Even\n    );\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('MEDIAN', MEDIAN);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_MEDIAN = ((/* unused pure expression or super */ null && (MEDIAN)));\n\n;// ./code/es-modules/Data/Formula/Functions/MIN.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentsValues: MIN_getArgumentsValues } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `MIN(...values)` implementation. Calculates the lowest\n * of the given values that are numbers.\n *\n * @private\n * @function Formula.processorFunctions.MIN\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction MIN(args, table) {\n    const values = MIN_getArgumentsValues(args, table);\n    let result = Number.POSITIVE_INFINITY;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (value < result) {\n                    result = value;\n                }\n                break;\n            case 'object':\n                value = MIN(value);\n                if (value < result) {\n                    result = value;\n                }\n                break;\n        }\n    }\n    return isFinite(result) ? result : 0;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('MIN', MIN);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_MIN = ((/* unused pure expression or super */ null && (MIN)));\n\n;// ./code/es-modules/Data/Formula/Functions/MOD.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: MOD_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `MOD(value1, value2)` implementation. Calculates the rest\n * of the division with the given values.\n *\n * @private\n * @function Formula.processorFunctions.MOD\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction MOD(args, table) {\n    let value1 = MOD_getArgumentValue(args[0], table), value2 = MOD_getArgumentValue(args[1], table);\n    if (typeof value1 === 'object') {\n        value1 = value1[0];\n    }\n    if (typeof value2 === 'object') {\n        value2 = value2[0];\n    }\n    if (typeof value1 !== 'number' ||\n        typeof value2 !== 'number' ||\n        value2 === 0) {\n        return NaN;\n    }\n    return value1 % value2;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('MOD', MOD);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_MOD = ((/* unused pure expression or super */ null && (MOD)));\n\n;// ./code/es-modules/Data/Formula/Functions/MODE.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Creates the mode map of the given arguments.\n *\n * @private\n * @function Formula.processorFunctions.MULT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to process.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction getModeMap(args, table) {\n    const modeMap = {}, values = Formula_FormulaProcessor.getArgumentsValues(args, table);\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    modeMap[value] = (modeMap[value] || 0) + 1;\n                }\n                break;\n            case 'object':\n                for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                    value2 = value[j];\n                    if (typeof value2 === 'number' &&\n                        !isNaN(value2)) {\n                        modeMap[value2] = (modeMap[value2] || 0) + 1;\n                    }\n                }\n                break;\n        }\n    }\n    return modeMap;\n}\n/**\n * Processor for the `MODE.MULT(...values)` implementation. Calculates the most\n * frequent values of the give values.\n *\n * @private\n * @function Formula.processorFunctions.MULT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to process.\n *\n * @return {number|Array<number>}\n * Result value of the process.\n */\nfunction MULT(args, table) {\n    const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n    if (!keys.length) {\n        return NaN;\n    }\n    let modeKeys = [parseFloat(keys[0])], modeCount = modeMap[keys[0]];\n    for (let i = 1, iEnd = keys.length, key, count; i < iEnd; ++i) {\n        key = keys[i];\n        count = modeMap[key];\n        if (modeCount < count) {\n            modeKeys = [parseFloat(key)];\n            modeCount = count;\n        }\n        else if (modeCount === count) {\n            modeKeys.push(parseFloat(key));\n        }\n    }\n    return modeCount > 1 ? modeKeys : NaN;\n}\n/**\n * Processor for the `MODE.SNGL(...values)` implementation. Calculates the\n * lowest most frequent value of the give values.\n *\n * @private\n * @function Formula.processorFunctions['MODE.SNGL']\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to process.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction SNGL(args, table) {\n    const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n    if (!keys.length) {\n        return NaN;\n    }\n    let modeKey = parseFloat(keys[0]), modeCount = modeMap[keys[0]];\n    for (let i = 1, iEnd = keys.length, key, keyValue, count; i < iEnd; ++i) {\n        key = keys[i];\n        count = modeMap[key];\n        if (modeCount < count) {\n            modeKey = parseFloat(key);\n            modeCount = count;\n        }\n        else if (modeCount === count) {\n            keyValue = parseFloat(key);\n            if (modeKey > keyValue) {\n                modeKey = keyValue;\n                modeCount = count;\n            }\n        }\n    }\n    return modeCount > 1 ? modeKey : NaN;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('MODE', SNGL);\nFormula_FormulaProcessor.registerProcessorFunction('MODE.MULT', MULT);\nFormula_FormulaProcessor.registerProcessorFunction('MODE.SNGL', SNGL);\n/* *\n *\n *  Default Export\n *\n * */\nconst MODE = {\n    MULT,\n    SNGL\n};\n/* harmony default export */ const Functions_MODE = ((/* unused pure expression or super */ null && (MODE)));\n\n;// ./code/es-modules/Data/Formula/Functions/NOT.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: NOT_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `NOT(value)` implementation. Returns the opposite test\n * result.\n *\n * @private\n * @function Formula.processorFunctions.NOT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {boolean|number}\n * Result value of the process.\n */\nfunction NOT(args, table) {\n    let value = NOT_getArgumentValue(args[0], table);\n    if (typeof value === 'object') {\n        value = value[0];\n    }\n    switch (typeof value) {\n        case 'boolean':\n        case 'number':\n            return !value;\n    }\n    return NaN;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('NOT', NOT);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_NOT = ((/* unused pure expression or super */ null && (NOT)));\n\n;// ./code/es-modules/Data/Formula/Functions/OR.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: OR_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `OR(...tests)` implementation. Returns `TRUE`, if one test\n * result is not `0` or `FALSE`.\n *\n * @private\n * @function Formula.processorFunctions.AND\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {boolean}\n * Result value of the process.\n */\nfunction OR(args, table) {\n    for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n        value = OR_getArgumentValue(args[i], table);\n        if (typeof value === 'object') {\n            if (OR(value, table)) {\n                return true;\n            }\n        }\n        else if (value) {\n            return true;\n        }\n    }\n    return false;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('OR', OR);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_OR = ((/* unused pure expression or super */ null && (OR)));\n\n;// ./code/es-modules/Data/Formula/Functions/PRODUCT.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentsValues: PRODUCT_getArgumentsValues } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `PRODUCT(...values)` implementation. Calculates the product\n * of the given values.\n *\n * @private\n * @function Formula.processorFunctions.PRODUCT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction PRODUCT(args, table) {\n    const values = PRODUCT_getArgumentsValues(args, table);\n    let result = 1, calculated = false;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    calculated = true;\n                    result *= value;\n                }\n                break;\n            case 'object':\n                calculated = true;\n                result *= PRODUCT(value, table);\n                break;\n        }\n    }\n    return (calculated ? result : 0);\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('PRODUCT', PRODUCT);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_PRODUCT = ((/* unused pure expression or super */ null && (PRODUCT)));\n\n;// ./code/es-modules/Data/Formula/Functions/SUM.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `SUM(...values)` implementation. Calculates the sum of the\n * given values.\n *\n * @private\n * @function Formula.processorFunctions.SUM\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to process.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction SUM(args, table) {\n    const values = Formula_FormulaProcessor.getArgumentsValues(args, table);\n    let result = 0;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    result += value;\n                }\n                break;\n            case 'object':\n                result += SUM(value, table);\n                break;\n        }\n    }\n    return result;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('SUM', SUM); // ð\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_SUM = ((/* unused pure expression or super */ null && (SUM)));\n\n;// ./code/es-modules/Data/Formula/Functions/XOR.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: XOR_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `XOR(...tests)` implementation. Returns `TRUE`, if at least\n * one of the given tests differs in result of other tests.\n *\n * @private\n * @function Formula.processorFunctions.AND\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {boolean|number}\n * Result value of the process.\n */\nfunction XOR(args, table) {\n    for (let i = 0, iEnd = args.length, lastValue, value; i < iEnd; ++i) {\n        value = XOR_getArgumentValue(args[i], table);\n        switch (typeof value) {\n            case 'boolean':\n            case 'number':\n                if (typeof lastValue === 'undefined') {\n                    lastValue = !!value;\n                }\n                else if (!!value !== lastValue) {\n                    return true;\n                }\n                break;\n            case 'object':\n                for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                    value2 = value[j];\n                    switch (typeof value2) {\n                        case 'boolean':\n                        case 'number':\n                            if (typeof lastValue === 'undefined') {\n                                lastValue = !!value2;\n                            }\n                            else if (!!value2 !== lastValue) {\n                                return true;\n                            }\n                            break;\n                    }\n                }\n                break;\n        }\n    }\n    return false;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('XOR', XOR);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_XOR = ((/* unused pure expression or super */ null && (XOR)));\n\n;// ./code/es-modules/Data/Formula/Formula.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n/* *\n *\n *  Imports\n *\n * */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* *\n *\n *  Default Export\n *\n * */\n/**\n * Formula engine to make use of spreadsheet formula strings.\n * @internal\n */\nconst Formula = {\n    ...Formula_FormulaParser,\n    ...Formula_FormulaProcessor,\n    ...FormulaTypes\n};\n/* harmony default export */ const Formula_Formula = (Formula);\n\n;// ./code/es-modules/Data/Converters/CSVConverter.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Torstein HÃ¸nsi\n *  - Christer Vasseng\n *  - GÃ¸ran Slettemark\n *  - Sophie Bremer\n *\n * */\n\n\n\nconst { merge: CSVConverter_merge } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Handles parsing and transforming CSV to a table.\n *\n * @private\n */\nclass CSVConverter extends Converters_DataConverter {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of the CSV parser.\n     *\n     * @param {CSVConverter.UserOptions} [options]\n     * Options for the CSV parser.\n     */\n    constructor(options) {\n        const mergedOptions = CSVConverter_merge(CSVConverter.defaultOptions, options);\n        super(mergedOptions);\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        this.columns = [];\n        this.headers = [];\n        this.dataTypes = [];\n        this.options = mergedOptions;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Creates a CSV string from the datatable on the connector instance.\n     *\n     * @param {DataConnector} connector\n     * Connector instance to export from.\n     *\n     * @param {CSVConverter.Options} [options]\n     * Options used for the export.\n     *\n     * @return {string}\n     * CSV string from the connector table.\n     */\n    export(connector, options = this.options) {\n        const { useLocalDecimalPoint, lineDelimiter } = options, exportNames = (this.options.firstRowAsNames !== false);\n        let { decimalPoint, itemDelimiter } = options;\n        if (!decimalPoint) {\n            decimalPoint = (itemDelimiter !== ',' && useLocalDecimalPoint ?\n                (1.1).toLocaleString()[1] :\n                '.');\n        }\n        if (!itemDelimiter) {\n            itemDelimiter = (decimalPoint === ',' ? ';' : ',');\n        }\n        const columns = connector.getSortedColumns(options.usePresentationOrder), columnNames = Object.keys(columns), csvRows = [], columnsCount = columnNames.length;\n        const rowArray = [];\n        // Add the names as the first row if they should be exported\n        if (exportNames) {\n            csvRows.push(columnNames.map((columnName) => `\"${columnName}\"`).join(itemDelimiter));\n        }\n        for (let columnIndex = 0; columnIndex < columnsCount; columnIndex++) {\n            const columnName = columnNames[columnIndex], column = columns[columnName], columnLength = column.length;\n            const columnMeta = connector.whatIs(columnName);\n            let columnDataType;\n            if (columnMeta) {\n                columnDataType = columnMeta.dataType;\n            }\n            for (let rowIndex = 0; rowIndex < columnLength; rowIndex++) {\n                let cellValue = column[rowIndex];\n                if (!rowArray[rowIndex]) {\n                    rowArray[rowIndex] = [];\n                }\n                // Prefer datatype from metadata\n                if (columnDataType === 'string') {\n                    cellValue = '\"' + cellValue + '\"';\n                }\n                else if (typeof cellValue === 'number') {\n                    cellValue = String(cellValue).replace('.', decimalPoint);\n                }\n                else if (typeof cellValue === 'string') {\n                    cellValue = `\"${cellValue}\"`;\n                }\n                rowArray[rowIndex][columnIndex] = cellValue;\n                // On the final column, push the row to the CSV\n                if (columnIndex === columnsCount - 1) {\n                    // Trim repeated undefined values starting at the end\n                    // Currently, we export the first \"comma\" even if the\n                    // second value is undefined\n                    let i = columnIndex;\n                    while (rowArray[rowIndex].length > 2) {\n                        const cellVal = rowArray[rowIndex][i];\n                        if (cellVal !== void 0) {\n                            break;\n                        }\n                        rowArray[rowIndex].pop();\n                        i--;\n                    }\n                    csvRows.push(rowArray[rowIndex].join(itemDelimiter));\n                }\n            }\n        }\n        return csvRows.join(lineDelimiter);\n    }\n    /**\n     * Initiates parsing of CSV\n     *\n     * @param {CSVConverter.UserOptions}[options]\n     * Options for the parser\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits CSVDataParser#parse\n     * @emits CSVDataParser#afterParse\n     */\n    parse(options, eventDetail) {\n        const converter = this, dataTypes = converter.dataTypes, parserOptions = CSVConverter_merge(this.options, options), { beforeParse, lineDelimiter, firstRowAsNames, itemDelimiter } = parserOptions;\n        let lines, rowIt = 0, { csv, startRow, endRow } = parserOptions, column;\n        converter.columns = [];\n        converter.emit({\n            type: 'parse',\n            columns: converter.columns,\n            detail: eventDetail,\n            headers: converter.headers\n        });\n        if (csv && beforeParse) {\n            csv = beforeParse(csv);\n        }\n        if (csv) {\n            lines = csv\n                .replace(/\\r\\n|\\r/g, '\\n') // Windows | Mac\n                .split(lineDelimiter || '\\n');\n            if (!startRow || startRow < 0) {\n                startRow = 0;\n            }\n            if (!endRow || endRow >= lines.length) {\n                endRow = lines.length - 1;\n            }\n            if (!itemDelimiter) {\n                converter.guessedItemDelimiter =\n                    converter.guessDelimiter(lines);\n            }\n            // If the first row contain names, add them to the\n            // headers array and skip the row.\n            if (firstRowAsNames) {\n                const headers = lines[0].split(itemDelimiter || converter.guessedItemDelimiter || ',');\n                // Remove \"\"s from the headers\n                for (let i = 0; i < headers.length; i++) {\n                    headers[i] = headers[i].trim().replace(/^[\"']|[\"']$/g, '');\n                }\n                converter.headers = headers;\n                startRow++;\n            }\n            let offset = 0;\n            for (rowIt = startRow; rowIt <= endRow; rowIt++) {\n                if (lines[rowIt][0] === '#') {\n                    offset++;\n                }\n                else {\n                    converter\n                        .parseCSVRow(lines[rowIt], rowIt - startRow - offset);\n                }\n            }\n            if (dataTypes.length &&\n                dataTypes[0].length &&\n                dataTypes[0][1] === 'date' && // Format is a string date\n                !converter.options.dateFormat) {\n                converter.deduceDateFormat(converter.columns[0], null, true);\n            }\n            // Guess types.\n            for (let i = 0, iEnd = converter.columns.length; i < iEnd; ++i) {\n                column = converter.columns[i];\n                for (let j = 0, jEnd = column.length; j < jEnd; ++j) {\n                    if (column[j] && typeof column[j] === 'string') {\n                        let cellValue = converter.asGuessedType(column[j]);\n                        if (cellValue instanceof Date) {\n                            cellValue = cellValue.getTime();\n                        }\n                        converter.columns[i][j] = cellValue;\n                    }\n                }\n            }\n        }\n        converter.emit({\n            type: 'afterParse',\n            columns: converter.columns,\n            detail: eventDetail,\n            headers: converter.headers\n        });\n    }\n    /**\n     * Internal method that parses a single CSV row\n     */\n    parseCSVRow(columnStr, rowNumber) {\n        const converter = this, columns = converter.columns || [], dataTypes = converter.dataTypes, { startColumn, endColumn } = converter.options, itemDelimiter = (converter.options.itemDelimiter ||\n            converter.guessedItemDelimiter);\n        let { decimalPoint } = converter.options;\n        if (!decimalPoint || decimalPoint === itemDelimiter) {\n            decimalPoint = converter.guessedDecimalPoint || '.';\n        }\n        let i = 0, c = '', token = '', actualColumn = 0, column = 0;\n        const read = (j) => {\n            c = columnStr[j];\n        };\n        const pushType = (type) => {\n            if (dataTypes.length < column + 1) {\n                dataTypes.push([type]);\n            }\n            if (dataTypes[column][dataTypes[column].length - 1] !== type) {\n                dataTypes[column].push(type);\n            }\n        };\n        const push = () => {\n            if (startColumn > actualColumn || actualColumn > endColumn) {\n                // Skip this column, but increment the column count (#7272)\n                ++actualColumn;\n                token = '';\n                return;\n            }\n            // Save the type of the token.\n            if (typeof token === 'string') {\n                if (!isNaN(parseFloat(token)) && isFinite(token)) {\n                    token = parseFloat(token);\n                    pushType('number');\n                }\n                else if (!isNaN(Date.parse(token))) {\n                    token = token.replace(/\\//g, '-');\n                    pushType('date');\n                }\n                else {\n                    pushType('string');\n                }\n            }\n            else {\n                pushType('number');\n            }\n            if (columns.length < column + 1) {\n                columns.push([]);\n            }\n            // Try to apply the decimal point, and check if the token then is a\n            // number. If not, reapply the initial value\n            if (typeof token !== 'number' &&\n                converter.guessType(token) !== 'number' &&\n                decimalPoint) {\n                const initialValue = token;\n                token = token.replace(decimalPoint, '.');\n                if (converter.guessType(token) !== 'number') {\n                    token = initialValue;\n                }\n            }\n            columns[column][rowNumber] = token;\n            token = '';\n            ++column;\n            ++actualColumn;\n        };\n        if (!columnStr.trim().length) {\n            return;\n        }\n        if (columnStr.trim()[0] === '#') {\n            return;\n        }\n        for (; i < columnStr.length; i++) {\n            read(i);\n            if (c === '#') {\n                // If there are hexvalues remaining (#13283)\n                if (!/^#[A-F\\d]{3,3}|[A-F\\d]{6,6}/i.test(columnStr.substring(i))) {\n                    // The rest of the row is a comment\n                    push();\n                    return;\n                }\n            }\n            // Quoted string\n            if (c === '\"') {\n                read(++i);\n                while (i < columnStr.length) {\n                    if (c === '\"') {\n                        break;\n                    }\n                    token += c;\n                    read(++i);\n                }\n            }\n            else if (c === itemDelimiter) {\n                push();\n                // Actual column data\n            }\n            else {\n                token += c;\n            }\n        }\n        push();\n    }\n    /**\n     * Internal method that guesses the delimiter from the first\n     * 13 lines of the CSV\n     * @param {Array<string>} lines\n     * The CSV, split into lines\n     */\n    guessDelimiter(lines) {\n        let points = 0, commas = 0, guessed;\n        const potDelimiters = {\n            ',': 0,\n            ';': 0,\n            '\\t': 0\n        }, linesCount = lines.length;\n        for (let i = 0; i < linesCount; i++) {\n            let inStr = false, c, cn, cl, token = '';\n            // We should be able to detect dateformats within 13 rows\n            if (i > 13) {\n                break;\n            }\n            const columnStr = lines[i];\n            for (let j = 0; j < columnStr.length; j++) {\n                c = columnStr[j];\n                cn = columnStr[j + 1];\n                cl = columnStr[j - 1];\n                if (c === '#') {\n                    // Skip the rest of the line - it's a comment\n                    break;\n                }\n                if (c === '\"') {\n                    if (inStr) {\n                        if (cl !== '\"' && cn !== '\"') {\n                            while (cn === ' ' && j < columnStr.length) {\n                                cn = columnStr[++j];\n                            }\n                            // After parsing a string, the next non-blank\n                            // should be a delimiter if the CSV is properly\n                            // formed.\n                            if (typeof potDelimiters[cn] !== 'undefined') {\n                                potDelimiters[cn]++;\n                            }\n                            inStr = false;\n                        }\n                    }\n                    else {\n                        inStr = true;\n                    }\n                }\n                else if (typeof potDelimiters[c] !== 'undefined') {\n                    token = token.trim();\n                    if (!isNaN(Date.parse(token))) {\n                        potDelimiters[c]++;\n                    }\n                    else if (isNaN(Number(token)) ||\n                        !isFinite(Number(token))) {\n                        potDelimiters[c]++;\n                    }\n                    token = '';\n                }\n                else {\n                    token += c;\n                }\n                if (c === ',') {\n                    commas++;\n                }\n                if (c === '.') {\n                    points++;\n                }\n            }\n        }\n        // Count the potential delimiters.\n        // This could be improved by checking if the number of delimiters\n        // equals the number of columns - 1\n        if (potDelimiters[';'] > potDelimiters[',']) {\n            guessed = ';';\n        }\n        else if (potDelimiters[','] > potDelimiters[';']) {\n            guessed = ',';\n        }\n        else {\n            // No good guess could be made..\n            guessed = ',';\n        }\n        // Try to deduce the decimal point if it's not explicitly set.\n        // If both commas or points is > 0 there is likely an issue\n        if (points > commas) {\n            this.guessedDecimalPoint = '.';\n        }\n        else {\n            this.guessedDecimalPoint = ',';\n        }\n        return guessed;\n    }\n    /**\n     * Handles converting the parsed data to a table.\n     *\n     * @return {DataTable}\n     * Table from the parsed CSV.\n     */\n    getTable() {\n        return Converters_DataConverter.getTableFromColumns(this.columns, this.headers);\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default options\n */\nCSVConverter.defaultOptions = {\n    ...Converters_DataConverter.defaultOptions,\n    lineDelimiter: '\\n'\n};\nConverters_DataConverter.registerType('CSV', CSVConverter);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Converters_CSVConverter = (CSVConverter);\n\n;// ./code/es-modules/Data/Connectors/CSVConnector.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Torstein HÃ¸nsi\n *  - Christer Vasseng\n *  - GÃ¸ran Slettemark\n *  - Sophie Bremer\n *\n * */\n\n\n\n\nconst { merge: CSVConnector_merge, defined: CSVConnector_defined } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Class that handles creating a DataConnector from CSV\n *\n * @private\n */\nclass CSVConnector extends Connectors_DataConnector {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of CSVConnector.\n     *\n     * @param {CSVConnector.UserOptions} [options]\n     * Options for the connector and converter.\n     *\n     * @param {Array<DataTableOptions>} [dataTables]\n     * Multiple connector data tables options.\n     *\n     */\n    constructor(options, dataTables) {\n        const mergedOptions = CSVConnector_merge(CSVConnector.defaultOptions, options);\n        super(mergedOptions, dataTables);\n        this.options = CSVConnector_defined(dataTables) ?\n            CSVConnector_merge(mergedOptions, { dataTables }) : mergedOptions;\n        if (mergedOptions.enablePolling) {\n            this.startPolling(Math.max(mergedOptions.dataRefreshRate || 0, 1) * 1000);\n        }\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Initiates the loading of the CSV source to the connector\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits CSVConnector#load\n     * @emits CSVConnector#afterLoad\n     */\n    load(eventDetail) {\n        const connector = this, tables = connector.dataTables, { csv, csvURL, dataModifier, dataTables } = connector.options;\n        connector.emit({\n            type: 'load',\n            csv,\n            detail: eventDetail,\n            tables\n        });\n        return Promise\n            .resolve(csvURL ?\n            fetch(csvURL, {\n                signal: connector?.pollingController?.signal\n            }).then((response) => response.text()) :\n            csv || '')\n            .then((csv) => {\n            if (csv) {\n                this.initConverters(csv, (key) => {\n                    const options = this.options;\n                    const tableOptions = dataTables?.find((dataTable) => dataTable.key === key);\n                    // Takes over the connector default options.\n                    const mergedTableOptions = {\n                        dataTableKey: key,\n                        firstRowAsNames: tableOptions?.firstRowAsNames ??\n                            options.firstRowAsNames,\n                        beforeParse: tableOptions?.beforeParse ??\n                            options.beforeParse\n                    };\n                    return new Converters_CSVConverter(CSVConnector_merge(this.options, mergedTableOptions));\n                }, (converter, data) => {\n                    converter.parse({ csv: data });\n                });\n            }\n            return connector\n                .setModifierOptions(dataModifier, dataTables)\n                .then(() => csv);\n        })\n            .then((csv) => {\n            connector.emit({\n                type: 'afterLoad',\n                csv,\n                detail: eventDetail,\n                tables\n            });\n            return connector;\n        })['catch']((error) => {\n            connector.emit({\n                type: 'loadError',\n                detail: eventDetail,\n                error,\n                tables\n            });\n            throw error;\n        });\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nCSVConnector.defaultOptions = {\n    csv: '',\n    csvURL: '',\n    enablePolling: false,\n    dataRefreshRate: 1,\n    firstRowAsNames: true\n};\nConnectors_DataConnector.registerType('CSV', CSVConnector);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Connectors_CSVConnector = ((/* unused pure expression or super */ null && (CSVConnector)));\n\n;// ./code/es-modules/Data/Converters/JSONConverter.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Pawel Lysy\n *\n * */\n\n\n\n\nconst { error, isArray, merge: JSONConverter_merge, objectEach: JSONConverter_objectEach } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Handles parsing and transforming JSON to a table.\n *\n * @private\n */\nclass JSONConverter extends Converters_DataConverter {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of the JSON parser.\n     *\n     * @param {JSONConverter.UserOptions} [options]\n     * Options for the JSON parser.\n     */\n    constructor(options) {\n        const mergedOptions = JSONConverter_merge(JSONConverter.defaultOptions, options);\n        super(mergedOptions);\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        this.columns = [];\n        this.headers = [];\n        this.options = mergedOptions;\n        this.table = new Data_DataTable();\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Initiates parsing of JSON structure.\n     *\n     * @param {JSONConverter.UserOptions}[options]\n     * Options for the parser\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits JSONConverter#parse\n     * @emits JSONConverter#afterParse\n     */\n    parse(options, eventDetail) {\n        const converter = this;\n        options = JSONConverter_merge(converter.options, options);\n        const { beforeParse, orientation, firstRowAsNames, columnNames } = options;\n        let data = options.data;\n        if (!data) {\n            return;\n        }\n        converter.columns = [];\n        converter.emit({\n            type: 'parse',\n            columns: converter.columns,\n            detail: eventDetail,\n            headers: converter.headers\n        });\n        if (beforeParse) {\n            data = beforeParse(data);\n        }\n        data = data.slice();\n        if (orientation === 'columns') {\n            for (let i = 0, iEnd = data.length; i < iEnd; i++) {\n                const item = data[i];\n                if (!(item instanceof Array)) {\n                    return;\n                }\n                if (converter.headers instanceof Array) {\n                    if (firstRowAsNames) {\n                        converter.headers.push(`${item.shift()}`);\n                    }\n                    else if (columnNames && columnNames instanceof Array) {\n                        converter.headers.push(columnNames[i]);\n                    }\n                    converter.table.setColumn(converter.headers[i] || i.toString(), item);\n                }\n                else {\n                    error('JSONConverter: Invalid `columnNames` option.', false);\n                }\n            }\n        }\n        else if (orientation === 'rows') {\n            if (firstRowAsNames) {\n                converter.headers = data.shift();\n            }\n            else if (columnNames) {\n                converter.headers = columnNames;\n            }\n            for (let rowIndex = 0, iEnd = data.length; rowIndex < iEnd; rowIndex++) {\n                let row = data[rowIndex];\n                if (isArray(row)) {\n                    for (let columnIndex = 0, jEnd = row.length; columnIndex < jEnd; columnIndex++) {\n                        if (converter.columns.length < columnIndex + 1) {\n                            converter.columns.push([]);\n                        }\n                        converter.columns[columnIndex].push(row[columnIndex]);\n                        if (converter.headers instanceof Array) {\n                            this.table.setColumn(converter.headers[columnIndex] ||\n                                columnIndex.toString(), converter.columns[columnIndex]);\n                        }\n                        else {\n                            error('JSONConverter: Invalid `columnNames` option.', false);\n                        }\n                    }\n                }\n                else {\n                    const columnNames = converter.headers;\n                    if (columnNames && !(columnNames instanceof Array)) {\n                        const newRow = {};\n                        JSONConverter_objectEach(columnNames, (arrayWithPath, name) => {\n                            newRow[name] = arrayWithPath.reduce((acc, key) => acc[key], row);\n                        });\n                        row = newRow;\n                    }\n                    this.table.setRows([row], rowIndex);\n                }\n            }\n        }\n        converter.emit({\n            type: 'afterParse',\n            columns: converter.columns,\n            detail: eventDetail,\n            headers: converter.headers\n        });\n    }\n    /**\n     * Handles converting the parsed data to a table.\n     *\n     * @return {DataTable}\n     * Table from the parsed CSV.\n     */\n    getTable() {\n        return this.table;\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default options\n */\nJSONConverter.defaultOptions = {\n    ...Converters_DataConverter.defaultOptions,\n    orientation: 'rows'\n};\nConverters_DataConverter.registerType('JSON', JSONConverter);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Converters_JSONConverter = (JSONConverter);\n\n;// ./code/es-modules/Data/Connectors/JSONConnector.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Pawel Lysy\n *\n * */\n\n\n\n\nconst { merge: JSONConnector_merge, defined: JSONConnector_defined } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Class that handles creating a DataConnector from JSON structure\n *\n * @private\n */\nclass JSONConnector extends Connectors_DataConnector {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of JSONConnector.\n     *\n     * @param {JSONConnector.UserOptions} [options]\n     * Options for the connector and converter.\n     *\n     * @param {Array<DataTableOptions>} [dataTables]\n     * Multiple connector data tables options.\n     */\n    constructor(options, dataTables) {\n        const mergedOptions = JSONConnector_merge(JSONConnector.defaultOptions, options);\n        super(mergedOptions, dataTables);\n        this.options = JSONConnector_defined(dataTables) ?\n            JSONConnector_merge(mergedOptions, { dataTables }) : mergedOptions;\n        if (mergedOptions.enablePolling) {\n            this.startPolling(Math.max(mergedOptions.dataRefreshRate || 0, 1) * 1000);\n        }\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Initiates the loading of the JSON source to the connector\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits JSONConnector#load\n     * @emits JSONConnector#afterLoad\n     */\n    load(eventDetail) {\n        const connector = this, tables = connector.dataTables, { data, dataUrl, dataModifier, dataTables } = connector.options;\n        connector.emit({\n            type: 'load',\n            data,\n            detail: eventDetail,\n            tables\n        });\n        return Promise\n            .resolve(dataUrl ?\n            fetch(dataUrl, {\n                signal: connector?.pollingController?.signal\n            }).then((response) => response.json())['catch']((error) => {\n                connector.emit({\n                    type: 'loadError',\n                    detail: eventDetail,\n                    error,\n                    tables\n                });\n                console.warn(`Unable to fetch data from ${dataUrl}.`); // eslint-disable-line no-console\n            }) :\n            data || [])\n            .then((data) => {\n            if (data) {\n                this.initConverters(data, (key) => {\n                    const options = this.options;\n                    const tableOptions = dataTables?.find((dataTable) => dataTable.key === key);\n                    // Takes over the connector default options.\n                    const mergedTableOptions = {\n                        dataTableKey: key,\n                        columnNames: tableOptions?.columnNames ??\n                            options.columnNames,\n                        firstRowAsNames: tableOptions?.firstRowAsNames ??\n                            options.firstRowAsNames,\n                        orientation: tableOptions?.orientation ??\n                            options.orientation,\n                        beforeParse: tableOptions?.beforeParse ??\n                            options.beforeParse\n                    };\n                    return new Converters_JSONConverter(JSONConnector_merge(this.options, mergedTableOptions));\n                }, (converter, data) => {\n                    converter.parse({ data });\n                });\n            }\n            return connector.setModifierOptions(dataModifier, dataTables)\n                .then(() => data);\n        })\n            .then((data) => {\n            connector.emit({\n                type: 'afterLoad',\n                data,\n                detail: eventDetail,\n                tables\n            });\n            return connector;\n        })['catch']((error) => {\n            connector.emit({\n                type: 'loadError',\n                detail: eventDetail,\n                error,\n                tables\n            });\n            throw error;\n        });\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nJSONConnector.defaultOptions = {\n    enablePolling: false,\n    dataRefreshRate: 0,\n    firstRowAsNames: true,\n    orientation: 'rows'\n};\nConnectors_DataConnector.registerType('JSON', JSONConnector);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Connectors_JSONConnector = ((/* unused pure expression or super */ null && (JSONConnector)));\n\n;// ./code/es-modules/Data/Converters/GoogleSheetsConverter.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Torstein HÃ¸nsi\n *  - GÃ¸ran Slettemark\n *  - Wojciech Chmiel\n *  - Sophie Bremer\n *\n * */\n\n\n\nconst { merge: GoogleSheetsConverter_merge, uniqueKey: GoogleSheetsConverter_uniqueKey } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Handles parsing and transformation of an Google Sheets to a table.\n *\n * @private\n */\nclass GoogleSheetsConverter extends Converters_DataConverter {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of the GoogleSheetsConverter.\n     *\n     * @param {GoogleSheetsConverter.UserOptions} [options]\n     * Options for the GoogleSheetsConverter.\n     */\n    constructor(options) {\n        const mergedOptions = GoogleSheetsConverter_merge(GoogleSheetsConverter.defaultOptions, options);\n        super(mergedOptions);\n        this.columns = [];\n        this.header = [];\n        this.options = mergedOptions;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Initiates the parsing of the Google Sheet\n     *\n     * @param {GoogleSheetsConverter.UserOptions}[options]\n     * Options for the parser\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits GoogleSheetsParser#parse\n     * @emits GoogleSheetsParser#afterParse\n     */\n    parse(options, eventDetail) {\n        const converter = this, parseOptions = GoogleSheetsConverter_merge(converter.options, options);\n        let columns = ((parseOptions.json?.values) || []).map((column) => column.slice());\n        if (columns.length === 0) {\n            return false;\n        }\n        converter.header = [];\n        converter.columns = [];\n        converter.emit({\n            type: 'parse',\n            columns: converter.columns,\n            detail: eventDetail,\n            headers: converter.header\n        });\n        // If beforeParse is defined, use it to modify the data\n        const { beforeParse, json } = parseOptions;\n        if (beforeParse && json) {\n            columns = beforeParse(json.values);\n        }\n        let column;\n        converter.columns = columns;\n        for (let i = 0, iEnd = columns.length; i < iEnd; i++) {\n            column = columns[i];\n            converter.header[i] = (parseOptions.firstRowAsNames ?\n                `${column.shift()}` :\n                GoogleSheetsConverter_uniqueKey());\n            for (let j = 0, jEnd = column.length; j < jEnd; ++j) {\n                if (column[j] && typeof column[j] === 'string') {\n                    let cellValue = converter.asGuessedType(column[j]);\n                    if (cellValue instanceof Date) {\n                        cellValue = cellValue.getTime();\n                    }\n                    converter.columns[i][j] = cellValue;\n                }\n            }\n        }\n        converter.emit({\n            type: 'afterParse',\n            columns: converter.columns,\n            detail: eventDetail,\n            headers: converter.header\n        });\n    }\n    /**\n     * Handles converting the parsed data to a table.\n     *\n     * @return {DataTable}\n     * Table from the parsed Google Sheet\n     */\n    getTable() {\n        return Converters_DataConverter.getTableFromColumns(this.columns, this.header);\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default options\n */\nGoogleSheetsConverter.defaultOptions = {\n    ...Converters_DataConverter.defaultOptions\n};\nConverters_DataConverter.registerType('GoogleSheets', GoogleSheetsConverter);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Converters_GoogleSheetsConverter = (GoogleSheetsConverter);\n\n;// ./code/es-modules/Data/Connectors/GoogleSheetsConnector.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Torstein HÃ¸nsi\n *  - GÃ¸ran Slettemark\n *  - Wojciech Chmiel\n *  - Sophie Bremer\n *  - Jomar HÃ¸nsi\n *\n * */\n\n\n\n\nconst { merge: GoogleSheetsConnector_merge, pick: GoogleSheetsConnector_pick, defined: GoogleSheetsConnector_defined } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Tests Google's response for error.\n * @private\n */\nfunction isGoogleError(json) {\n    return (typeof json === 'object' && json &&\n        typeof json.error === 'object' && json.error &&\n        typeof json.error.code === 'number' &&\n        typeof json.error.message === 'string' &&\n        typeof json.error.status === 'string');\n}\n/* *\n *\n *  Class\n *\n * */\n/**\n * @private\n * @todo implement save, requires oauth2\n */\nclass GoogleSheetsConnector extends Connectors_DataConnector {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of GoogleSheetsConnector\n     *\n     * @param {GoogleSheetsConnector.UserOptions} [options]\n     * Options for the connector and converter.\n     *\n     * @param {Array<DataTableOptions>} [dataTables]\n     * Multiple connector data tables options.\n     *\n     */\n    constructor(options, dataTables) {\n        const mergedOptions = GoogleSheetsConnector_merge(GoogleSheetsConnector.defaultOptions, options);\n        super(mergedOptions, dataTables);\n        this.options = GoogleSheetsConnector_defined(dataTables) ?\n            GoogleSheetsConnector_merge(mergedOptions, { dataTables }) : mergedOptions;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Loads data from a Google Spreadsheet.\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Promise<this>}\n     * Same connector instance with modified table.\n     */\n    load(eventDetail) {\n        const connector = this, tables = connector.dataTables, { dataModifier, dataRefreshRate, enablePolling, googleAPIKey, googleSpreadsheetKey, dataTables } = connector.options, url = GoogleSheetsConnector.buildFetchURL(googleAPIKey, googleSpreadsheetKey, connector.options);\n        connector.emit({\n            type: 'load',\n            detail: eventDetail,\n            tables,\n            url\n        });\n        if (!URL.canParse(url)) {\n            throw new Error('Invalid URL: ' + url);\n        }\n        return fetch(url, { signal: connector?.pollingController?.signal })\n            .then((response) => (response.json()))\n            .then((json) => {\n            if (isGoogleError(json)) {\n                throw new Error(json.error.message);\n            }\n            this.initConverters(json, (key) => {\n                const options = this.options;\n                const tableOptions = dataTables?.find((dataTable) => dataTable.key === key);\n                // Takes over the connector default options.\n                const mergedTableOptions = {\n                    dataTableKey: key,\n                    firstRowAsNames: tableOptions?.firstRowAsNames ??\n                        options.firstRowAsNames,\n                    beforeParse: tableOptions?.beforeParse ??\n                        options.beforeParse\n                };\n                return new Converters_GoogleSheetsConverter(GoogleSheetsConnector_merge(this.options, mergedTableOptions));\n            }, (converter, data) => {\n                converter.parse({ json: data });\n            });\n            return connector.setModifierOptions(dataModifier, dataTables);\n        })\n            .then(() => {\n            connector.emit({\n                type: 'afterLoad',\n                detail: eventDetail,\n                tables,\n                url\n            });\n            // Polling\n            if (enablePolling) {\n                setTimeout(() => connector.load(), Math.max(dataRefreshRate || 0, 1) * 1000);\n            }\n            return connector;\n        })['catch']((error) => {\n            connector.emit({\n                type: 'loadError',\n                detail: eventDetail,\n                error,\n                tables\n            });\n            throw error;\n        });\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nGoogleSheetsConnector.defaultOptions = {\n    googleAPIKey: '',\n    googleSpreadsheetKey: '',\n    enablePolling: false,\n    dataRefreshRate: 2,\n    firstRowAsNames: true\n};\n/* *\n *\n *  Class Namespace\n *\n * */\n(function (GoogleSheetsConnector) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Constants\n     *\n     * */\n    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Creates GoogleSheets API v4 URL.\n     * @private\n     */\n    function buildFetchURL(apiKey, sheetKey, options = {}) {\n        const url = new URL(`https://sheets.googleapis.com/v4/spreadsheets/${sheetKey}/values/`);\n        const range = options.onlyColumnNames ?\n            'A1:Z1' : buildQueryRange(options);\n        url.pathname += range;\n        const searchParams = url.searchParams;\n        searchParams.set('alt', 'json');\n        if (!options.onlyColumnNames) {\n            searchParams.set('dateTimeRenderOption', 'FORMATTED_STRING');\n            searchParams.set('majorDimension', 'COLUMNS');\n            searchParams.set('valueRenderOption', 'UNFORMATTED_VALUE');\n        }\n        searchParams.set('prettyPrint', 'false');\n        searchParams.set('key', apiKey);\n        return url.href;\n    }\n    GoogleSheetsConnector.buildFetchURL = buildFetchURL;\n    /**\n     * Creates sheets range.\n     * @private\n     */\n    function buildQueryRange(options = {}) {\n        const { endColumn, endRow, googleSpreadsheetRange, startColumn, startRow } = options;\n        return googleSpreadsheetRange || ((alphabet[startColumn || 0] || 'A') +\n            (Math.max((startRow || 0), 0) + 1) +\n            ':' +\n            (alphabet[GoogleSheetsConnector_pick(endColumn, 25)] || 'Z') +\n            (endRow ?\n                Math.max(endRow, 0) :\n                'Z'));\n    }\n    GoogleSheetsConnector.buildQueryRange = buildQueryRange;\n})(GoogleSheetsConnector || (GoogleSheetsConnector = {}));\nConnectors_DataConnector.registerType('GoogleSheets', GoogleSheetsConnector);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Connectors_GoogleSheetsConnector = ((/* unused pure expression or super */ null && (GoogleSheetsConnector)));\n\n;// ./code/es-modules/Data/Converters/HTMLTableConverter.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Torstein HÃ¸nsi\n *  - GÃ¸ran Slettemark\n *  - Wojciech Chmiel\n *  - Sophie Bremer\n *\n * */\n\n\n\nconst { merge: HTMLTableConverter_merge } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Row equal\n */\nfunction isRowEqual(row1, row2) {\n    let i = row1.length;\n    if (row2.length === i) {\n        while (--i) {\n            if (row1[i] !== row2[i]) {\n                return false;\n            }\n        }\n    }\n    else {\n        return false;\n    }\n    return true;\n}\n/* *\n *\n *  Class\n *\n * */\n/**\n * Handles parsing and transformation of an HTML table to a table.\n *\n * @private\n */\nclass HTMLTableConverter extends Converters_DataConverter {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of the HTMLTableConverter.\n     *\n     * @param {HTMLTableConverter.UserOptions} [options]\n     * Options for the HTMLTableConverter.\n     */\n    constructor(options) {\n        const mergedOptions = HTMLTableConverter_merge(HTMLTableConverter.defaultOptions, options);\n        super(mergedOptions);\n        this.columns = [];\n        this.headers = [];\n        this.options = mergedOptions;\n        if (mergedOptions.tableElement) {\n            this.tableElement = mergedOptions.tableElement;\n            this.tableElementID = mergedOptions.tableElement.id;\n        }\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Exports the dataconnector as an HTML string, using the options\n     * provided on import unless other options are provided.\n     *\n     * @param {DataConnector} connector\n     * Connector instance to export from.\n     *\n     * @param {HTMLTableConnector.ExportOptions} [options]\n     * Options that override default or existing export options.\n     *\n     * @return {string}\n     * HTML from the current dataTable.\n     */\n    export(connector, options = this.options) {\n        const exportNames = (options.firstRowAsNames !== false), useMultiLevelHeaders = options.useMultiLevelHeaders;\n        const columns = connector.getSortedColumns(options.usePresentationOrder), columnNames = Object.keys(columns), htmlRows = [], columnsCount = columnNames.length;\n        const rowArray = [];\n        let tableHead = '';\n        // Add the names as the first row if they should be exported\n        if (exportNames) {\n            const subcategories = [];\n            // If using multilevel headers, the first value\n            // of each column is a subcategory\n            if (useMultiLevelHeaders) {\n                for (const name of columnNames) {\n                    let column = columns[name];\n                    if (!Array.isArray(column)) {\n                        // Convert to conventional array from typed array\n                        // if needed\n                        column = Array.from(column);\n                    }\n                    const subhead = (column.shift() || '').toString();\n                    columns[name] = column;\n                    subcategories.push(subhead);\n                }\n                tableHead = this.getTableHeaderHTML(columnNames, subcategories, options);\n            }\n            else {\n                tableHead = this.getTableHeaderHTML(void 0, columnNames, options);\n            }\n        }\n        for (let columnIndex = 0; columnIndex < columnsCount; columnIndex++) {\n            const columnName = columnNames[columnIndex], column = columns[columnName], columnLength = column.length;\n            for (let rowIndex = 0; rowIndex < columnLength; rowIndex++) {\n                let cellValue = column[rowIndex];\n                if (!rowArray[rowIndex]) {\n                    rowArray[rowIndex] = [];\n                }\n                // Alternative: Datatype from HTML attribute with\n                // connector.whatIs(columnName)\n                if (!(typeof cellValue === 'string' ||\n                    typeof cellValue === 'number' ||\n                    typeof cellValue === 'undefined')) {\n                    cellValue = (cellValue || '').toString();\n                }\n                rowArray[rowIndex][columnIndex] = this.getCellHTMLFromValue(columnIndex ? 'td' : 'th', null, columnIndex ? '' : 'scope=\"row\"', cellValue);\n                // On the final column, push the row to the array\n                if (columnIndex === columnsCount - 1) {\n                    htmlRows.push('<tr>' +\n                        rowArray[rowIndex].join('') +\n                        '</tr>');\n                }\n            }\n        }\n        let caption = '';\n        // Add table caption\n        // Current exportdata falls back to chart title\n        // but that should probably be handled elsewhere?\n        if (options.tableCaption) {\n            caption = '<caption class=\"highcharts-table-caption\">' +\n                options.tableCaption +\n                '</caption>';\n        }\n        return ('<table>' +\n            caption +\n            tableHead +\n            '<tbody>' +\n            htmlRows.join('') +\n            '</tbody>' +\n            '</table>');\n    }\n    /**\n     * Get table cell markup from row data.\n     */\n    getCellHTMLFromValue(tag, classes, attrs, value, decimalPoint) {\n        let val = value, className = 'text' + (classes ? ' ' + classes : '');\n        // Convert to string if number\n        if (typeof val === 'number') {\n            val = val.toString();\n            if (decimalPoint === ',') {\n                val = val.replace('.', decimalPoint);\n            }\n            className = 'number';\n        }\n        else if (!value) {\n            val = '';\n            className = 'empty';\n        }\n        return '<' + tag + (attrs ? ' ' + attrs : '') +\n            ' class=\"' + className + '\">' +\n            val + '</' + tag + '>';\n    }\n    /**\n     * Get table header markup from row data.\n     */\n    getTableHeaderHTML(topheaders = [], subheaders = [], options = this.options) {\n        const { useMultiLevelHeaders, useRowspanHeaders } = options;\n        let html = '<thead>', i = 0, len = subheaders && subheaders.length, next, cur, curColspan = 0, rowspan;\n        // Clean up multiple table headers. Exporting.getDataRows() returns two\n        // levels of headers when using multilevel, not merged. We need to\n        // merge identical headers, remove redundant headers, and keep it\n        // all marked up nicely.\n        if (useMultiLevelHeaders &&\n            topheaders &&\n            subheaders &&\n            !isRowEqual(topheaders, subheaders)) {\n            html += '<tr>';\n            for (; i < len; ++i) {\n                cur = topheaders[i];\n                next = topheaders[i + 1];\n                if (cur === next) {\n                    ++curColspan;\n                }\n                else if (curColspan) {\n                    // Ended colspan\n                    // Add cur to HTML with colspan.\n                    html += this.getCellHTMLFromValue('th', 'highcharts-table-topheading', 'scope=\"col\" ' +\n                        'colspan=\"' + (curColspan + 1) + '\"', cur);\n                    curColspan = 0;\n                }\n                else {\n                    // Cur is standalone. If it is same as sublevel,\n                    // remove sublevel and add just toplevel.\n                    if (cur === subheaders[i]) {\n                        if (useRowspanHeaders) {\n                            rowspan = 2;\n                            subheaders.splice(i, 1);\n                        }\n                        else {\n                            rowspan = 1;\n                            subheaders[i] = '';\n                        }\n                    }\n                    else {\n                        rowspan = 1;\n                    }\n                    html += this.getCellHTMLFromValue('th', 'highcharts-table-topheading', 'scope=\"col\"' +\n                        (rowspan > 1 ?\n                            ' valign=\"top\" rowspan=\"' + rowspan + '\"' :\n                            ''), cur);\n                }\n            }\n            html += '</tr>';\n        }\n        // Add the subheaders (the only headers if not using multilevels)\n        if (subheaders) {\n            html += '<tr>';\n            for (i = 0, len = subheaders.length; i < len; ++i) {\n                if (typeof subheaders[i] !== 'undefined') {\n                    html += this.getCellHTMLFromValue('th', null, 'scope=\"col\"', subheaders[i]);\n                }\n            }\n            html += '</tr>';\n        }\n        html += '</thead>';\n        return html;\n    }\n    /**\n     * Initiates the parsing of the HTML table\n     *\n     * @param {HTMLTableConverter.UserOptions}[options]\n     * Options for the parser\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits CSVDataParser#parse\n     * @emits CSVDataParser#afterParse\n     * @emits HTMLTableParser#parseError\n     */\n    parse(options, eventDetail) {\n        const converter = this, columns = [], headers = [], parseOptions = HTMLTableConverter_merge(converter.options, options), { endRow, startColumn, endColumn, firstRowAsNames } = parseOptions, tableHTML = parseOptions.tableElement || this.tableElement;\n        if (!(tableHTML instanceof HTMLElement)) {\n            converter.emit({\n                type: 'parseError',\n                columns,\n                detail: eventDetail,\n                headers,\n                error: 'Not a valid HTML Table'\n            });\n            return;\n        }\n        converter.tableElement = tableHTML;\n        converter.tableElementID = tableHTML.id;\n        this.emit({\n            type: 'parse',\n            columns: converter.columns,\n            detail: eventDetail,\n            headers: converter.headers\n        });\n        const rows = tableHTML.getElementsByTagName('tr'), rowsCount = rows.length;\n        let rowIndex = 0, item, { startRow } = parseOptions;\n        // Insert headers from the first row\n        if (firstRowAsNames && rowsCount) {\n            const items = rows[0].children, itemsLength = items.length;\n            for (let i = startColumn; i < itemsLength; i++) {\n                if (i > endColumn) {\n                    break;\n                }\n                item = items[i];\n                if (item.tagName === 'TD' ||\n                    item.tagName === 'TH') {\n                    headers.push(item.innerHTML);\n                }\n            }\n            startRow++;\n        }\n        while (rowIndex < rowsCount) {\n            if (rowIndex >= startRow && rowIndex <= endRow) {\n                const columnsInRow = rows[rowIndex].children, columnsInRowLength = columnsInRow.length;\n                let columnIndex = 0;\n                while (columnIndex < columnsInRowLength) {\n                    const relativeColumnIndex = columnIndex - startColumn, row = columns[relativeColumnIndex];\n                    item = columnsInRow[columnIndex];\n                    if ((item.tagName === 'TD' ||\n                        item.tagName === 'TH') &&\n                        (columnIndex >= startColumn &&\n                            columnIndex <= endColumn)) {\n                        if (!columns[relativeColumnIndex]) {\n                            columns[relativeColumnIndex] = [];\n                        }\n                        let cellValue = converter.asGuessedType(item.innerHTML);\n                        if (cellValue instanceof Date) {\n                            cellValue = cellValue.getTime();\n                        }\n                        columns[relativeColumnIndex][rowIndex - startRow] = cellValue;\n                        // Loop over all previous indices and make sure\n                        // they are nulls, not undefined.\n                        let i = 1;\n                        while (rowIndex - startRow >= i &&\n                            row[rowIndex - startRow - i] === void 0) {\n                            row[rowIndex - startRow - i] = null;\n                            i++;\n                        }\n                    }\n                    columnIndex++;\n                }\n            }\n            rowIndex++;\n        }\n        this.columns = columns;\n        this.headers = headers;\n        this.emit({\n            type: 'afterParse',\n            columns,\n            detail: eventDetail,\n            headers\n        });\n    }\n    /**\n     * Handles converting the parsed data to a table.\n     *\n     * @return {DataTable}\n     * Table from the parsed HTML table\n     */\n    getTable() {\n        return Converters_DataConverter.getTableFromColumns(this.columns, this.headers);\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default options\n */\nHTMLTableConverter.defaultOptions = {\n    ...Converters_DataConverter.defaultOptions,\n    useRowspanHeaders: true,\n    useMultiLevelHeaders: true\n};\nConverters_DataConverter.registerType('HTMLTable', HTMLTableConverter);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Converters_HTMLTableConverter = (HTMLTableConverter);\n\n;// ./code/es-modules/Data/Connectors/HTMLTableConnector.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Torstein HÃ¸nsi\n *  - GÃ¸ran Slettemark\n *  - Wojciech Chmiel\n *  - Sophie Bremer\n *\n * */\n\n\n\nconst { win } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n\n\nconst { merge: HTMLTableConnector_merge } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Class that handles creating a data connector from an HTML table.\n *\n * @private\n */\nclass HTMLTableConnector extends Connectors_DataConnector {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of HTMLTableConnector.\n     *\n     * @param {HTMLTableConnector.UserOptions} [options]\n     * Options for the connector and converter.\n     */\n    constructor(options) {\n        const mergedOptions = HTMLTableConnector_merge(HTMLTableConnector.defaultOptions, options);\n        super(mergedOptions);\n        this.converter = new Converters_HTMLTableConverter(mergedOptions);\n        this.options = mergedOptions;\n    }\n    /**\n     * Initiates creating the dataconnector from the HTML table\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits HTMLTableConnector#load\n     * @emits HTMLTableConnector#afterLoad\n     * @emits HTMLTableConnector#loadError\n     */\n    load(eventDetail) {\n        const connector = this, converter = connector.converter, table = connector.table, { dataModifier, table: tableHTML } = connector.options;\n        connector.emit({\n            type: 'load',\n            detail: eventDetail,\n            tables: { table },\n            tableElement: connector.tableElement\n        });\n        let tableElement;\n        if (typeof tableHTML === 'string') {\n            connector.tableID = tableHTML;\n            tableElement = win.document.getElementById(tableHTML);\n        }\n        else {\n            tableElement = tableHTML;\n            connector.tableID = tableElement.id;\n        }\n        connector.tableElement = tableElement || void 0;\n        if (!connector.tableElement) {\n            const error = 'HTML table not provided, or element with ID not found';\n            connector.emit({\n                type: 'loadError',\n                detail: eventDetail,\n                error,\n                tables: { table }\n            });\n            return Promise.reject(new Error(error));\n        }\n        converter.parse(HTMLTableConnector_merge({ tableElement: connector.tableElement }, connector.options), eventDetail);\n        // If already loaded, clear the current rows\n        table.deleteColumns();\n        table.setColumns(converter.getTable().getColumns());\n        return connector\n            .setModifierOptions(dataModifier)\n            .then(() => {\n            connector.emit({\n                type: 'afterLoad',\n                detail: eventDetail,\n                tables: { table },\n                tableElement: connector.tableElement\n            });\n            return connector;\n        });\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nHTMLTableConnector.defaultOptions = {\n    table: ''\n};\nConnectors_DataConnector.registerType('HTMLTable', HTMLTableConnector);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Connectors_HTMLTableConnector = ((/* unused pure expression or super */ null && (HTMLTableConnector)));\n\n;// ./code/es-modules/Data/Modifiers/ChainModifier.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *  - Dawid Dragula\n *\n * */\n\n\n\nconst { merge: ChainModifier_merge } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Modifies a table with the help of modifiers in an ordered chain.\n *\n */\nclass ChainModifier extends Modifiers_DataModifier {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of the modifier chain.\n     *\n     * @param {Partial<ChainModifier.Options>} [options]\n     * Options to configure the modifier chain.\n     *\n     * @param {...DataModifier} [chain]\n     * Ordered chain of modifiers.\n     */\n    constructor(options, ...chain) {\n        super();\n        this.chain = chain;\n        this.options = ChainModifier_merge(ChainModifier.defaultOptions, options);\n        const optionsChain = this.options.chain || [];\n        for (let i = 0, iEnd = optionsChain.length, modifierOptions, ModifierClass; i < iEnd; ++i) {\n            modifierOptions = optionsChain[i];\n            if (!modifierOptions.type) {\n                continue;\n            }\n            ModifierClass = Modifiers_DataModifier.types[modifierOptions.type];\n            if (ModifierClass) {\n                chain.push(new ModifierClass(modifierOptions));\n            }\n        }\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Adds a configured modifier to the end of the modifier chain. Please note,\n     * that the modifier can be added multiple times.\n     *\n     * @param {DataModifier} modifier\n     * Configured modifier to add.\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     */\n    add(modifier, eventDetail) {\n        this.emit({\n            type: 'addModifier',\n            detail: eventDetail,\n            modifier\n        });\n        this.chain.push(modifier);\n        this.emit({\n            type: 'addModifier',\n            detail: eventDetail,\n            modifier\n        });\n    }\n    /**\n     * Clears all modifiers from the chain.\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     */\n    clear(eventDetail) {\n        this.emit({\n            type: 'clearChain',\n            detail: eventDetail\n        });\n        this.chain.length = 0;\n        this.emit({\n            type: 'afterClearChain',\n            detail: eventDetail\n        });\n    }\n    /**\n     * Applies several modifications to the table and returns a modified copy of\n     * the given table.\n     *\n     * @param {Highcharts.DataTable} table\n     * Table to modify.\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Promise<Highcharts.DataTable>}\n     * Table with `modified` property as a reference.\n     */\n    async modify(table, eventDetail) {\n        const modifiers = (this.options.reverse ?\n            this.chain.slice().reverse() :\n            this.chain.slice());\n        if (table.modified === table) {\n            table.modified = table.clone(false, eventDetail);\n        }\n        let modified = table;\n        for (let i = 0, iEnd = modifiers.length; i < iEnd; ++i) {\n            try {\n                await modifiers[i].modify(modified, eventDetail);\n            }\n            catch (error) {\n                this.emit({\n                    type: 'error',\n                    detail: eventDetail,\n                    table\n                });\n                throw error;\n            }\n            modified = modified.modified;\n        }\n        table.modified = modified;\n        return table;\n    }\n    /**\n     * Applies partial modifications of a cell change to the property `modified`\n     * of the given modified table.\n     *\n     * *Note:* The `modified` property of the table gets replaced.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {string} columnName\n     * Column name of changed cell.\n     *\n     * @param {number|undefined} rowIndex\n     * Row index of changed cell.\n     *\n     * @param {Highcharts.DataTableCellType} cellValue\n     * Changed cell value.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyCell(table, columnName, rowIndex, cellValue, eventDetail) {\n        const modifiers = (this.options.reverse ?\n            this.chain.reverse() :\n            this.chain);\n        if (modifiers.length) {\n            let clone = table.clone();\n            for (let i = 0, iEnd = modifiers.length; i < iEnd; ++i) {\n                modifiers[i].modifyCell(clone, columnName, rowIndex, cellValue, eventDetail);\n                clone = clone.modified;\n            }\n            table.modified = clone;\n        }\n        return table;\n    }\n    /**\n     * Applies partial modifications of column changes to the property\n     * `modified` of the given table.\n     *\n     * *Note:* The `modified` property of the table gets replaced.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {Highcharts.DataTableColumnCollection} columns\n     * Changed columns as a collection, where the keys are the column names.\n     *\n     * @param {number} [rowIndex=0]\n     * Index of the first changed row.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyColumns(table, columns, rowIndex, eventDetail) {\n        const modifiers = (this.options.reverse ?\n            this.chain.reverse() :\n            this.chain.slice());\n        if (modifiers.length) {\n            let clone = table.clone();\n            for (let i = 0, iEnd = modifiers.length; i < iEnd; ++i) {\n                modifiers[i].modifyColumns(clone, columns, rowIndex, eventDetail);\n                clone = clone.modified;\n            }\n            table.modified = clone;\n        }\n        return table;\n    }\n    /**\n     * Applies partial modifications of row changes to the property `modified`\n     * of the given table.\n     *\n     * *Note:* The `modified` property of the table gets replaced.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {Array<(Highcharts.DataTableRow|Highcharts.DataTableRowObject)>} rows\n     * Changed rows.\n     *\n     * @param {number} [rowIndex]\n     * Index of the first changed row.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyRows(table, rows, rowIndex, eventDetail) {\n        const modifiers = (this.options.reverse ?\n            this.chain.reverse() :\n            this.chain.slice());\n        if (modifiers.length) {\n            let clone = table.clone();\n            for (let i = 0, iEnd = modifiers.length; i < iEnd; ++i) {\n                modifiers[i].modifyRows(clone, rows, rowIndex, eventDetail);\n                clone = clone.modified;\n            }\n            table.modified = clone;\n        }\n        return table;\n    }\n    /**\n     * Applies several modifications to the table.\n     *\n     * *Note:* The `modified` property of the table gets replaced.\n     *\n     * @param {DataTable} table\n     * Table to modify.\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {DataTable}\n     * Table as a reference.\n     *\n     * @emits ChainDataModifier#execute\n     * @emits ChainDataModifier#afterExecute\n     */\n    modifyTable(table, eventDetail) {\n        const chain = this;\n        chain.emit({\n            type: 'modify',\n            detail: eventDetail,\n            table\n        });\n        const modifiers = (chain.options.reverse ?\n            chain.chain.reverse() :\n            chain.chain.slice());\n        let modified = table.modified;\n        for (let i = 0, iEnd = modifiers.length, modifier; i < iEnd; ++i) {\n            modifier = modifiers[i];\n            modified = modifier.modifyTable(modified, eventDetail).modified;\n        }\n        table.modified = modified;\n        chain.emit({\n            type: 'afterModify',\n            detail: eventDetail,\n            table\n        });\n        return table;\n    }\n    /**\n     * Removes a configured modifier from all positions in the modifier chain.\n     *\n     * @param {DataModifier} modifier\n     * Configured modifier to remove.\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     */\n    remove(modifier, eventDetail) {\n        const modifiers = this.chain;\n        this.emit({\n            type: 'removeModifier',\n            detail: eventDetail,\n            modifier\n        });\n        modifiers.splice(modifiers.indexOf(modifier), 1);\n        this.emit({\n            type: 'afterRemoveModifier',\n            detail: eventDetail,\n            modifier\n        });\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default option for the ordered modifier chain.\n */\nChainModifier.defaultOptions = {\n    type: 'Chain'\n};\nModifiers_DataModifier.registerType('Chain', ChainModifier);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Modifiers_ChainModifier = ((/* unused pure expression or super */ null && (ChainModifier)));\n\n;// ./code/es-modules/Data/Modifiers/InvertModifier.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Wojciech Chmiel\n *  - Sophie Bremer\n *\n * */\n\n\n\nconst { merge: InvertModifier_merge } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Inverts columns and rows in a table.\n *\n * @private\n */\nclass InvertModifier extends Modifiers_DataModifier {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of the invert modifier.\n     *\n     * @param {Partial<InvertModifier.Options>} [options]\n     * Options to configure the invert modifier.\n     */\n    constructor(options) {\n        super();\n        this.options = InvertModifier_merge(InvertModifier.defaultOptions, options);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Applies partial modifications of a cell change to the property `modified`\n     * of the given modified table.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {string} columnName\n     * Column name of changed cell.\n     *\n     * @param {number|undefined} rowIndex\n     * Row index of changed cell.\n     *\n     * @param {Highcharts.DataTableCellType} cellValue\n     * Changed cell value.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyCell(table, columnName, rowIndex, cellValue, eventDetail) {\n        const modified = table.modified, modifiedRowIndex = modified.getRowIndexBy('columnNames', columnName);\n        if (typeof modifiedRowIndex === 'undefined') {\n            modified.setColumns(this.modifyTable(table.clone()).getColumns(), void 0, eventDetail);\n        }\n        else {\n            modified.setCell(`${rowIndex}`, modifiedRowIndex, cellValue, eventDetail);\n        }\n        return table;\n    }\n    /**\n     * Applies partial modifications of column changes to the property\n     * `modified` of the given table.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {Highcharts.DataTableColumnCollection} columns\n     * Changed columns as a collection, where the keys are the column names.\n     *\n     * @param {number} [rowIndex=0]\n     * Index of the first changed row.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyColumns(table, columns, rowIndex, eventDetail) {\n        const modified = table.modified, modifiedColumnNames = (modified.getColumn('columnNames') || []);\n        let columnNames = table.getColumnNames(), reset = (table.getRowCount() !== modifiedColumnNames.length);\n        if (!reset) {\n            for (let i = 0, iEnd = columnNames.length; i < iEnd; ++i) {\n                if (columnNames[i] !== modifiedColumnNames[i]) {\n                    reset = true;\n                    break;\n                }\n            }\n        }\n        if (reset) {\n            return this.modifyTable(table, eventDetail);\n        }\n        columnNames = Object.keys(columns);\n        for (let i = 0, iEnd = columnNames.length, column, columnName, modifiedRowIndex; i < iEnd; ++i) {\n            columnName = columnNames[i];\n            column = columns[columnName];\n            modifiedRowIndex = (modified.getRowIndexBy('columnNames', columnName) ||\n                modified.getRowCount());\n            for (let j = 0, j2 = rowIndex, jEnd = column.length; j < jEnd; ++j, ++j2) {\n                modified.setCell(`${j2}`, modifiedRowIndex, column[j], eventDetail);\n            }\n        }\n        return table;\n    }\n    /**\n     * Applies partial modifications of row changes to the property `modified`\n     * of the given table.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {Array<(Highcharts.DataTableRow|Highcharts.DataTableRowObject)>} rows\n     * Changed rows.\n     *\n     * @param {number} [rowIndex]\n     * Index of the first changed row.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyRows(table, rows, rowIndex, eventDetail) {\n        const columnNames = table.getColumnNames(), modified = table.modified, modifiedColumnNames = (modified.getColumn('columnNames') || []);\n        let reset = (table.getRowCount() !== modifiedColumnNames.length);\n        if (!reset) {\n            for (let i = 0, iEnd = columnNames.length; i < iEnd; ++i) {\n                if (columnNames[i] !== modifiedColumnNames[i]) {\n                    reset = true;\n                    break;\n                }\n            }\n        }\n        if (reset) {\n            return this.modifyTable(table, eventDetail);\n        }\n        for (let i = 0, i2 = rowIndex, iEnd = rows.length, row; i < iEnd; ++i, ++i2) {\n            row = rows[i];\n            if (row instanceof Array) {\n                modified.setColumn(`${i2}`, row);\n            }\n            else {\n                for (let j = 0, jEnd = columnNames.length; j < jEnd; ++j) {\n                    modified.setCell(`${i2}`, j, row[columnNames[j]], eventDetail);\n                }\n            }\n        }\n        return table;\n    }\n    /**\n     * Inverts rows and columns in the table.\n     *\n     * @param {DataTable} table\n     * Table to invert.\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {DataTable}\n     * Table with inverted `modified` property as a reference.\n     */\n    modifyTable(table, eventDetail) {\n        const modifier = this;\n        modifier.emit({ type: 'modify', detail: eventDetail, table });\n        const modified = table.modified;\n        if (table.hasColumns(['columnNames'])) { // Inverted table\n            const columnNamesColumn = ((table.deleteColumns(['columnNames']) || {})\n                .columnNames || []), columns = {}, columnNames = [];\n            for (let i = 0, iEnd = columnNamesColumn.length; i < iEnd; ++i) {\n                columnNames.push('' + columnNamesColumn[i]);\n            }\n            for (let i = 0, iEnd = table.getRowCount(), row; i < iEnd; ++i) {\n                row = table.getRow(i);\n                if (row) {\n                    columns[columnNames[i]] = row;\n                }\n            }\n            modified.deleteColumns();\n            modified.setColumns(columns);\n        }\n        else { // Regular table\n            const columns = {};\n            for (let i = 0, iEnd = table.getRowCount(), row; i < iEnd; ++i) {\n                row = table.getRow(i);\n                if (row) {\n                    columns[`${i}`] = row;\n                }\n            }\n            columns.columnNames = table.getColumnNames();\n            modified.deleteColumns();\n            modified.setColumns(columns);\n        }\n        modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n        return table;\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default options for the invert modifier.\n */\nInvertModifier.defaultOptions = {\n    type: 'Invert'\n};\nModifiers_DataModifier.registerType('Invert', InvertModifier);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Modifiers_InvertModifier = ((/* unused pure expression or super */ null && (InvertModifier)));\n\n;// ./code/es-modules/Data/Modifiers/MathModifier.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n\n\n/* *\n *\n *  Class\n *\n * */\n/**\n * Replaces formula strings in a table with calculated values.\n *\n * @class\n * @name Highcharts.DataModifier.types.MathModifier\n * @augments Highcharts.DataModifier\n */\nclass MathModifier extends Modifiers_DataModifier {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    constructor(options) {\n        super();\n        this.options = {\n            ...MathModifier.defaultOptions,\n            ...options\n        };\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    modifyTable(table, eventDetail) {\n        const modifier = this;\n        modifier.emit({ type: 'modify', detail: eventDetail, table });\n        const alternativeSeparators = modifier.options.alternativeSeparators, formulaColumns = (modifier.options.formulaColumns ||\n            table.getColumnNames()), modified = table.modified;\n        for (let i = 0, iEnd = formulaColumns.length, columnName; i < iEnd; ++i) {\n            columnName = formulaColumns[i];\n            if (formulaColumns.indexOf(columnName) >= 0) {\n                modified.setColumn(columnName, modifier.processColumn(table, columnName));\n            }\n        }\n        const columnFormulas = (modifier.options.columnFormulas || []);\n        for (let i = 0, iEnd = columnFormulas.length, columnFormula, formula; i < iEnd; ++i) {\n            columnFormula = columnFormulas[i];\n            formula = Formula_FormulaParser.parseFormula(columnFormula.formula, alternativeSeparators);\n            modified.setColumn(columnFormula.column, modifier.processColumnFormula(formula, table, columnFormula.rowStart, columnFormula.rowEnd));\n        }\n        modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n        return table;\n    }\n    /**\n     * Process a column by replacing formula strings with calculated values.\n     *\n     * @private\n     *\n     * @param {Highcharts.DataTable} table\n     * Table to extract column from and use as reference.\n     *\n     * @param {string} columnName\n     * Name of column to process.\n     *\n     * @param {number} rowIndex\n     * Row index to start the replacing process from.\n     *\n     * @return {Highcharts.DataTableColumn}\n     * Returns the processed table column.\n     */\n    processColumn(table, columnName, rowIndex = 0) {\n        const alternativeSeparators = this.options.alternativeSeparators, column = (table.getColumn(columnName, true) || [])\n            .slice(rowIndex > 0 ? rowIndex : 0);\n        for (let i = 0, iEnd = column.length, cacheFormula = [], cacheString = '', cell; i < iEnd; ++i) {\n            cell = column[i];\n            if (typeof cell === 'string' &&\n                cell[0] === '=') {\n                try {\n                    // Use cache while formula string is repetitive\n                    cacheFormula = (cacheString === cell ?\n                        cacheFormula :\n                        Formula_FormulaParser.parseFormula(cell.substring(1), alternativeSeparators));\n                    // Process parsed formula string\n                    column[i] =\n                        Formula_FormulaProcessor.processFormula(cacheFormula, table);\n                }\n                catch {\n                    column[i] = NaN;\n                }\n            }\n        }\n        return column;\n    }\n    /**\n     * Process a column by replacing cell values with calculated values from a\n     * given formula.\n     *\n     * @private\n     *\n     * @param {Highcharts.Formula} formula\n     * Formula to use for processing.\n     *\n     * @param {Highcharts.DataTable} table\n     * Table to extract column from and use as reference.\n     *\n     * @param {number} rowStart\n     * Row index to start the replacing process from.\n     *\n     * @param {number} rowEnd\n     * Row index to end the replacing process.\n     *\n     * @return {Highcharts.DataTableColumn}\n     * Returns the processed table column.\n     */\n    processColumnFormula(formula, table, rowStart = 0, rowEnd = table.getRowCount()) {\n        rowStart = rowStart >= 0 ? rowStart : 0;\n        rowEnd = rowEnd >= 0 ? rowEnd : table.getRowCount() + rowEnd;\n        const column = [], modified = table.modified;\n        for (let i = 0, iEnd = (rowEnd - rowStart); i < iEnd; ++i) {\n            try {\n                column[i] = Formula_FormulaProcessor.processFormula(formula, modified);\n            }\n            catch {\n                column[i] = NaN;\n            }\n            finally {\n                formula = Formula_FormulaProcessor.translateReferences(formula, 0, 1);\n            }\n        }\n        return column;\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default options of MathModifier.\n * @private\n */\nMathModifier.defaultOptions = {\n    type: 'Math',\n    alternativeSeparators: false\n};\nModifiers_DataModifier.registerType('Math', MathModifier);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Modifiers_MathModifier = ((/* unused pure expression or super */ null && (MathModifier)));\n\n;// ./code/es-modules/Data/Modifiers/RangeModifier.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *  - Dawid Dragula\n *\n * */\n\n\n\nconst { merge: RangeModifier_merge } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Filters out table rows with a specific value range.\n *\n */\nclass RangeModifier extends Modifiers_DataModifier {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of the range modifier.\n     *\n     * @param {Partial<RangeModifier.Options>} [options]\n     * Options to configure the range modifier.\n     */\n    constructor(options) {\n        super();\n        this.options = RangeModifier_merge(RangeModifier.defaultOptions, options);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Replaces table rows with filtered rows.\n     *\n     * @param {DataTable} table\n     * Table to modify.\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyTable(table, eventDetail) {\n        const modifier = this;\n        modifier.emit({ type: 'modify', detail: eventDetail, table });\n        let indexes = [];\n        const { additive, ranges, strict } = modifier.options;\n        if (ranges.length) {\n            const modified = table.modified;\n            let columns = table.getColumns(), rows = [];\n            for (let i = 0, iEnd = ranges.length, range, rangeColumn; i < iEnd; ++i) {\n                range = ranges[i];\n                if (strict &&\n                    typeof range.minValue !== typeof range.maxValue) {\n                    continue;\n                }\n                if (i > 0 && !additive) {\n                    modified.deleteRows();\n                    modified.setRows(rows);\n                    modified.setOriginalRowIndexes(indexes, true);\n                    columns = modified.getColumns();\n                    rows = [];\n                    indexes = [];\n                }\n                rangeColumn = (columns[range.column] || []);\n                for (let j = 0, jEnd = rangeColumn.length, cell, row, originalRowIndex; j < jEnd; ++j) {\n                    cell = rangeColumn[j];\n                    switch (typeof cell) {\n                        default:\n                            continue;\n                        case 'boolean':\n                        case 'number':\n                        case 'string':\n                            break;\n                    }\n                    if (strict &&\n                        typeof cell !== typeof range.minValue) {\n                        continue;\n                    }\n                    if (cell >= range.minValue &&\n                        cell <= range.maxValue) {\n                        if (additive) {\n                            row = table.getRow(j);\n                            originalRowIndex = table.getOriginalRowIndex(j);\n                        }\n                        else {\n                            row = modified.getRow(j);\n                            originalRowIndex = modified.getOriginalRowIndex(j);\n                        }\n                        if (row) {\n                            rows.push(row);\n                            indexes.push(originalRowIndex);\n                        }\n                    }\n                }\n            }\n            modified.deleteRows();\n            modified.setRows(rows);\n            modified.setOriginalRowIndexes(indexes);\n        }\n        modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n        return table;\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default options for the range modifier.\n */\nRangeModifier.defaultOptions = {\n    type: 'Range',\n    ranges: []\n};\nModifiers_DataModifier.registerType('Range', RangeModifier);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Modifiers_RangeModifier = ((/* unused pure expression or super */ null && (RangeModifier)));\n\n;// ./code/es-modules/Data/Modifiers/SortModifier.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *  - Dawid Dragula\n *\n * */\n\n\n\n\nconst { merge: SortModifier_merge } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Sort table rows according to values of a column.\n *\n */\nclass SortModifier extends Modifiers_DataModifier {\n    /* *\n     *\n     *  Static Functions\n     *\n     * */\n    static ascending(a, b) {\n        return ((a || 0) < (b || 0) ? -1 :\n            (a || 0) > (b || 0) ? 1 :\n                0);\n    }\n    static descending(a, b) {\n        return ((b || 0) < (a || 0) ? -1 :\n            (b || 0) > (a || 0) ? 1 :\n                0);\n    }\n    static compareFactory(direction, customCompare) {\n        if (customCompare) {\n            if (direction === 'desc') {\n                return (a, b) => -customCompare(a, b);\n            }\n            return customCompare;\n        }\n        return (direction === 'asc' ?\n            SortModifier.ascending :\n            SortModifier.descending);\n    }\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of the range modifier.\n     *\n     * @param {Partial<RangeDataModifier.Options>} [options]\n     * Options to configure the range modifier.\n     */\n    constructor(options) {\n        super();\n        this.options = SortModifier_merge(SortModifier.defaultOptions, options);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Returns index and row for sort reference.\n     *\n     * @private\n     *\n     * @param {Highcharts.DataTable} table\n     * Table with rows to reference.\n     *\n     * @return {Array<SortModifier.RowReference>}\n     * Array of row references.\n     */\n    getRowReferences(table) {\n        const rows = table.getRows(), rowReferences = [];\n        for (let i = 0, iEnd = rows.length; i < iEnd; ++i) {\n            rowReferences.push({\n                index: i,\n                row: rows[i]\n            });\n        }\n        return rowReferences;\n    }\n    /**\n     * Applies partial modifications of a cell change to the property `modified`\n     * of the given modified table.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {string} columnName\n     * Column name of changed cell.\n     *\n     * @param {number|undefined} rowIndex\n     * Row index of changed cell.\n     *\n     * @param {Highcharts.DataTableCellType} cellValue\n     * Changed cell value.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyCell(table, columnName, rowIndex, cellValue, eventDetail) {\n        const modifier = this, { orderByColumn, orderInColumn } = modifier.options;\n        if (columnName === orderByColumn) {\n            if (orderInColumn) {\n                table.modified.setCell(columnName, rowIndex, cellValue);\n                table.modified.setColumn(orderInColumn, modifier\n                    .modifyTable(new Data_DataTable({\n                    columns: table\n                        .getColumns([orderByColumn, orderInColumn])\n                }))\n                    .modified\n                    .getColumn(orderInColumn));\n            }\n            else {\n                modifier.modifyTable(table, eventDetail);\n            }\n        }\n        return table;\n    }\n    /**\n     * Applies partial modifications of column changes to the property\n     * `modified` of the given table.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {Highcharts.DataTableColumnCollection} columns\n     * Changed columns as a collection, where the keys are the column names.\n     *\n     * @param {number} [rowIndex=0]\n     * Index of the first changed row.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyColumns(table, columns, rowIndex, eventDetail) {\n        const modifier = this, { orderByColumn, orderInColumn } = modifier.options, columnNames = Object.keys(columns);\n        if (columnNames.indexOf(orderByColumn) > -1) {\n            if (orderInColumn &&\n                columns[columnNames[0]].length) {\n                table.modified.setColumns(columns, rowIndex);\n                table.modified.setColumn(orderInColumn, modifier\n                    .modifyTable(new Data_DataTable({\n                    columns: table\n                        .getColumns([orderByColumn, orderInColumn])\n                }))\n                    .modified\n                    .getColumn(orderInColumn));\n            }\n            else {\n                modifier.modifyTable(table, eventDetail);\n            }\n        }\n        return table;\n    }\n    /**\n     * Applies partial modifications of row changes to the property `modified`\n     * of the given table.\n     *\n     * @param {Highcharts.DataTable} table\n     * Modified table.\n     *\n     * @param {Array<(Highcharts.DataTableRow|Highcharts.DataTableRowObject)>} rows\n     * Changed rows.\n     *\n     * @param {number} [rowIndex]\n     * Index of the first changed row.\n     *\n     * @param {Highcharts.DataTableEventDetail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {Highcharts.DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyRows(table, rows, rowIndex, eventDetail) {\n        const modifier = this, { orderByColumn, orderInColumn } = modifier.options;\n        if (orderInColumn &&\n            rows.length) {\n            table.modified.setRows(rows, rowIndex);\n            table.modified.setColumn(orderInColumn, modifier\n                .modifyTable(new Data_DataTable({\n                columns: table\n                    .getColumns([orderByColumn, orderInColumn])\n            }))\n                .modified\n                .getColumn(orderInColumn));\n        }\n        else {\n            modifier.modifyTable(table, eventDetail);\n        }\n        return table;\n    }\n    /**\n     * Sorts rows in the table.\n     *\n     * @param {DataTable} table\n     * Table to sort in.\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyTable(table, eventDetail) {\n        const modifier = this;\n        modifier.emit({ type: 'modify', detail: eventDetail, table });\n        const columnNames = table.getColumnNames(), rowCount = table.getRowCount(), rowReferences = this.getRowReferences(table), { direction, orderByColumn, orderInColumn, compare: customCompare } = modifier.options, compare = SortModifier.compareFactory(direction, customCompare), orderByColumnIndex = columnNames.indexOf(orderByColumn), modified = table.modified;\n        if (orderByColumnIndex !== -1) {\n            rowReferences.sort((a, b) => compare(a.row[orderByColumnIndex], b.row[orderByColumnIndex]));\n        }\n        if (orderInColumn) {\n            const column = [];\n            for (let i = 0; i < rowCount; ++i) {\n                column[rowReferences[i].index] = i;\n            }\n            modified.setColumns({ [orderInColumn]: column });\n        }\n        else {\n            const originalIndexes = [];\n            const rows = [];\n            let rowReference;\n            for (let i = 0; i < rowCount; ++i) {\n                rowReference = rowReferences[i];\n                originalIndexes.push(modified.getOriginalRowIndex(rowReference.index));\n                rows.push(rowReference.row);\n            }\n            modified.setRows(rows, 0);\n            modified.setOriginalRowIndexes(originalIndexes);\n        }\n        modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n        return table;\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default options to group table rows.\n */\nSortModifier.defaultOptions = {\n    type: 'Sort',\n    direction: 'desc',\n    orderByColumn: 'y'\n};\nModifiers_DataModifier.registerType('Sort', SortModifier);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Modifiers_SortModifier = ((/* unused pure expression or super */ null && (SortModifier)));\n\n;// ./code/es-modules/Data/Modifiers/FilterModifier.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Dawid Dragula\n *\n * */\n\n\n\nconst { isFunction: FilterModifier_isFunction, merge: FilterModifier_merge } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Filters out table rows matching a given condition.\n */\nclass FilterModifier extends Modifiers_DataModifier {\n    /* *\n     *\n     *  Static Functions\n     *\n     * */\n    /**\n     * Compiles a filter condition into a callback function.\n     *\n     * @param {FilterCondition} condition\n     * Condition to compile.\n     */\n    static compile(condition) {\n        if (FilterModifier_isFunction(condition)) {\n            return condition;\n        }\n        const op = condition.operator;\n        switch (op) {\n            case 'and': {\n                const subs = condition.conditions.map((c) => this.compile(c));\n                return (row, table, i) => subs.every((cond) => cond(row, table, i));\n            }\n            case 'or': {\n                const subs = condition.conditions.map((c) => this.compile(c));\n                return (row, table, i) => subs.some((cond) => cond(row, table, i));\n            }\n            case 'not': {\n                const sub = this.compile(condition.condition);\n                return (row, table, i) => !sub(row, table, i);\n            }\n        }\n        const { columnName: col, value } = condition;\n        switch (op) {\n            case '==':\n                // eslint-disable-next-line eqeqeq\n                return (row) => row[col] == value;\n            case '===':\n                return (row) => row[col] === value;\n            case '!=':\n                // eslint-disable-next-line eqeqeq\n                return (row) => row[col] != value;\n            case '!==':\n                return (row) => row[col] !== value;\n            case '>':\n                return (row) => (row[col] || 0) > (value || 0);\n            case '>=':\n                return (row) => (row[col] || 0) >= (value || 0);\n            case '<':\n                return (row) => (row[col] || 0) < (value || 0);\n            case '<=':\n                return (row) => (row[col] || 0) <= (value || 0);\n        }\n        const { ignoreCase } = condition;\n        const str = (val) => {\n            const s = '' + val;\n            return (ignoreCase ?? true) ? s.toLowerCase() : s;\n        };\n        switch (op) {\n            case 'contains':\n                return (row) => str(row[col]).includes(str(value));\n            default:\n                return (row) => str(row[col])[op](str(value));\n        }\n    }\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    /**\n     * Constructs an instance of the filter modifier.\n     *\n     * @param {Partial<FilterModifier.Options>} [options]\n     * Options to configure the filter modifier.\n     */\n    constructor(options) {\n        super();\n        this.options = FilterModifier_merge(FilterModifier.defaultOptions, options);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Replaces table rows with filtered rows.\n     *\n     * @param {DataTable} table\n     * Table to modify.\n     *\n     * @param {DataEvent.Detail} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @return {DataTable}\n     * Table with `modified` property as a reference.\n     */\n    modifyTable(table, eventDetail) {\n        const modifier = this;\n        modifier.emit({ type: 'modify', detail: eventDetail, table });\n        const { condition } = modifier.options;\n        if (!condition) {\n            // If no condition is set, return the unmodified table.\n            return table;\n        }\n        const matchRow = FilterModifier.compile(condition);\n        // This line should be investigated further when reworking Data Layer.\n        const modified = table.modified;\n        const rows = [];\n        const indexes = [];\n        for (let i = 0, iEnd = table.getRowCount(); i < iEnd; ++i) {\n            const row = table.getRowObject(i);\n            if (!row) {\n                continue;\n            }\n            if (matchRow(row, table, i)) {\n                rows.push(row);\n                indexes.push(modified.getOriginalRowIndex(i));\n            }\n        }\n        modified.deleteRows();\n        modified.setRows(rows);\n        modified.setOriginalRowIndexes(indexes);\n        modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n        return table;\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default options for the filter modifier.\n */\nFilterModifier.defaultOptions = {\n    type: 'Filter'\n};\nModifiers_DataModifier.registerType('Filter', FilterModifier);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Modifiers_FilterModifier = ((/* unused pure expression or super */ null && (FilterModifier)));\n\n;// ./code/es-modules/masters/modules/data-tools.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst G = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\nG.DataConnector = G.DataConnector || Connectors_DataConnector;\nG.DataConverter = G.DataConverter || Converters_DataConverter;\nG.DataCursor = G.DataCursor || Data_DataCursor;\nG.DataModifier = G.DataModifier || Modifiers_DataModifier;\nG.DataPool = G.DataPool || Data_DataPool;\nG.DataTable = G.DataTable || Data_DataTable;\nG.Formula = G.Formula || Formula_Formula;\n/* harmony default export */ const data_tools_src = ((highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()));\n\n__webpack_exports__ = __webpack_exports__[\"default\"];\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});"],"names":["root","factory","exports","module","define","amd","amd1","window","__WEBPACK_EXTERNAL_MODULE__944__","ColumnUtils","__webpack_modules__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","__webpack_exports__","data_tools_src","highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_","highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default","addEvent","fireEvent","merge","DataModifier","benchmark","dataTable","options","results","modifier","execute","modifyTable","emit","type","iterations","on","length","times","startTime","endTime","performance","now","push","e","modify","table","eventDetail","Promise","resolve","reject","modified","clone","detail","Error","modifyCell","columnName","rowIndex","cellValue","modifyColumns","columns","modifyRows","rows","callback","types","registerType","DataModifierClass","Modifiers_DataModifier","setLength","column","asSubarray","Array","isArray","splice","start","deleteCount","removedAsSubarray","items","from","removed","array","Constructor","getPrototypeOf","constructor","result","set","subarray","Data_ColumnUtils","DataTableCore_fireEvent","objectEach","uniqueKey","Data_DataTableCore","autoId","id","rowCount","versionTag","slice","Math","max","applyRowCount","deleteRows","getColumn","asReference","getColumns","columnNames","keys","reduce","getRow","map","setColumn","setColumns","silent","setRow","row","insert","indexRowCount","addColumns","DataTable_addEvent","defined","extend","DataTable_fireEvent","isNumber","DataTable_uniqueKey","DataTable","isNull","NULL","i","iEnd","skipColumns","tableOptions","tableClone","originalRowIndexes","localRowIndexes","deleteColumns","deletedColumns","modifiedColumns","deleteRowIndexReferences","deletedRows","modifiedRows","deletedCells","j","jEnd","includes","getCell","getCellAsBoolean","getCellAsNumber","useNaN","isNaN","parseFloat","getCellAsString","getColumnAsNumbers","columnAsNumber","columnLength","getColumnNames","asBasicColumns","tableColumns","getLocalRowIndex","originalRowIndex","getModifier","getOriginalRowIndex","getRows","getRowCount","getRowIndexBy","rowIndexOffset","indexOf","getRowObject","getRowObjects","i2","min","getVersionTag","hasColumns","hasRowWith","Number","isFinite","renameColumn","newColumnName","setCell","typeAsOriginal","tableModifier","tableColumn","ArrayConstructor","setModifier","promise","then","error","setOriginalRowIndexes","omitLocalRowIndexes","modifiedIndexes","originalIndex","setRows","version","DataConnector_addEvent","DataConnector_fireEvent","DataConnector_merge","pick","DataConnector","dataTables","loaded","metadata","dataTableIndex","polling","_polling","getTable","describeColumn","name","columnMeta","connector","describeColumns","pop","getColumnOrder","usePresentationState","names","sort","b","index","values","getSortedColumns","usePresentationOrder","load","save","setColumnOrder","setModifierOptions","modifierOptions","tablesOptions","entries","find","mergedModifierOptions","dataModifier","ModifierClass","startPolling","refreshTime","tables","pollingController","AbortController","clearTimeout","setTimeout","stopPolling","abort","whatIs","initConverters","data","createConverter","parseData","converter","DataConnectorClass","Connectors_DataConnector","DataConverter_addEvent","DataConverter_fireEvent","DataConverter_isNumber","DataConverter_merge","DataConverter","dateFormats","regex","parser","match","Date","UTC","NaN","alternative","year","getFullYear","mergedOptions","defaultOptions","regExpPoint","decimalPoint","decimalRegExp","RegExp","asBoolean","value","asNumber","asDate","timestamp","parseDate","asString","asGuessedType","typeMap","guessType","decimalRegex","replace","test","getDate","deduceDateFormat","limit","stable","format","thing","guessedFormat","madeDeduction","elem","trim","split","parseInt","join","dateFormat","export","headers","trimedValue","innerTrimedValue","floatValue","parse","dateFormatProp","getTime","getTimezoneOffset","str","inside","alternativeFormat","startColumn","endColumn","MAX_VALUE","startRow","endRow","firstRowAsNames","switchRowsAndColumns","DataConverterClass","getTableFromColumns","Converters_DataConverter","DataCursor","stateMap","emittingRegister","listenerMap","addListener","tableId","state","listener","listeners","buildEmittingTag","cursor","firstRow","lastRow","emitCursor","event","lasting","cursors","getIndex","emittingTag","remitCursor","removeListener","toRange","defaultRange","range","needle","columnNeedle","JSON","stringify","isEqual","cursorA","cursorB","isInRange","needleColumns","rangeColumns","every","toPositions","positions","rowEnd","columnEnd","Data_DataCursor","Data_DataPoolDefaults","connectors","DataPool","waiting","getConnector","connectorId","waitingList","connectorOptions","getConnectorOptions","loadConnector","getConnectorIds","connectorIds","getConnectorTable","isNewConnector","ConnectorClass","cancelPendingRequests","connectorKey","setConnectorOptions","instances","isString","booleanRegExp","decimal1RegExp","decimal2RegExp","functionRegExp","operatorRegExp","rangeA1RegExp","rangeR1C1RegExp","referenceA1RegExp","referenceR1C1RegExp","extractParantheses","text","parantheseLevel","char","parantheseStart","substring","extractString","escaping","parseArgument","alternativeSeparators","beginColumnRelative","beginRowRelative","endColumnRelative","endRowRelative","beginColumn","beginRow","parseReferenceColumn","formula","parseFormula","negativeReference","formulaLength","priorFormula","next","columnRelative","rowRelative","reference","isNegative","number","string","parantheses","args","parseArguments","argumentsSeparator","term","paranteses","position","code","factor","charCodeAt","pow","Formula_FormulaParser","operators","FormulaTypes","isFormula","item","isFunction","isOperator","isRange","isReference","isValue","FormulaProcessor_isFormula","FormulaProcessor_isFunction","FormulaProcessor_isOperator","FormulaProcessor_isRange","FormulaProcessor_isReference","FormulaProcessor_isValue","FormulaProcessor_defined","asLogicalStringRegExp","MAX_FALSE","MAX_STRING","MAX_TRUE","operatorPriority","processorFunctions","processorFunctionNameRegExp","asLogicalNumber","asLogicalString","toLowerCase","getArgumentValue","arg","getRangeValues","processFunction","processFormula","cell","cells","getReferenceValue","applyOperator","secondValue","firstValue","operator","basicOperation","x","y","round","expectingValue","formulaFunction","processor","Formula_FormulaProcessor","getArgumentsValues","registerProcessorFunction","processorFunction","translateReferences","columnDelta","rowDelta","ABS_getArgumentValue","abs","value2","AND_getArgumentValue","AND","AVERAGE_getArgumentsValues","count","AVERAGEA_getArgumentValue","COUNT","COUNTA","IF_getArgumentValue","ISNA_getArgumentValue","MAX_getArgumentsValues","MAX","NEGATIVE_INFINITY","median","half","floor","MIN_getArgumentsValues","MIN","POSITIVE_INFINITY","MOD_getArgumentValue","getModeMap","modeMap","SNGL","modeKey","modeCount","keyValue","value1","modeKeys","NOT_getArgumentValue","OR_getArgumentValue","OR","PRODUCT_getArgumentsValues","PRODUCT","calculated","SUM","XOR_getArgumentValue","lastValue","Formula","CSVConverter_merge","CSVConverter","dataTypes","useLocalDecimalPoint","lineDelimiter","exportNames","itemDelimiter","toLocaleString","csvRows","columnsCount","rowArray","columnIndex","columnDataType","dataType","String","cellVal","parserOptions","beforeParse","lines","rowIt","csv","guessedItemDelimiter","guessDelimiter","offset","parseCSVRow","columnStr","rowNumber","guessedDecimalPoint","c","token","actualColumn","read","pushType","initialValue","points","commas","guessed","potDelimiters","linesCount","inStr","cn","cl","CSVConnector_merge","CSVConnector_defined","CSVConnector","enablePolling","dataRefreshRate","csvURL","fetch","signal","response","mergedTableOptions","dataTableKey","JSONConverter_merge","JSONConverter_objectEach","JSONConverter","orientation","shift","toString","newRow","arrayWithPath","acc","JSONConnector_merge","JSONConnector_defined","JSONConnector","dataUrl","json","console","warn","GoogleSheetsConverter_merge","GoogleSheetsConverter_uniqueKey","GoogleSheetsConverter","header","parseOptions","GoogleSheetsConnector_merge","GoogleSheetsConnector_pick","GoogleSheetsConnector_defined","GoogleSheetsConnector","googleAPIKey","googleSpreadsheetKey","url","buildFetchURL","URL","canParse","message","status","alphabet","buildQueryRange","googleSpreadsheetRange","apiKey","sheetKey","onlyColumnNames","pathname","searchParams","href","HTMLTableConverter_merge","HTMLTableConverter","tableElement","tableElementID","useMultiLevelHeaders","htmlRows","tableHead","subcategories","subhead","getTableHeaderHTML","getCellHTMLFromValue","caption","tableCaption","tag","classes","attrs","val","className","topheaders","subheaders","useRowspanHeaders","html","len","cur","curColspan","rowspan","isRowEqual","row1","row2","tableHTML","HTMLElement","getElementsByTagName","rowsCount","children","itemsLength","tagName","innerHTML","columnsInRow","columnsInRowLength","relativeColumnIndex","win","HTMLTableConnector_merge","HTMLTableConnector","tableID","document","getElementById","ChainModifier_merge","ChainModifier","chain","optionsChain","add","clear","modifiers","reverse","remove","InvertModifier_merge","InvertModifier","modifiedRowIndex","modifiedColumnNames","reset","j2","columnNamesColumn","MathModifier","formulaColumns","processColumn","columnFormulas","columnFormula","processColumnFormula","rowStart","cacheFormula","cacheString","RangeModifier_merge","RangeModifier","indexes","additive","ranges","strict","rangeColumn","minValue","maxValue","SortModifier_merge","SortModifier","ascending","descending","compareFactory","direction","customCompare","getRowReferences","rowReferences","orderByColumn","orderInColumn","compare","orderByColumnIndex","rowReference","originalIndexes","FilterModifier_isFunction","FilterModifier_merge","FilterModifier","compile","condition","op","subs","conditions","cond","some","sub","col","ignoreCase","s","matchRow","G"],"mappings":"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"}